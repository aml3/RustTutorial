[Previous](01.md)	[Next](03.md)
* * *
The `let` keyword is used to
create variables. 

```rust
let x = 4;
let name = "Jeff";
```

Variables in Rust are immutable or mutable. By default, any variable is 
immutable. This means that doing an assignment, `let y = 5;`, and then trying to
assign a value to the variable later, `y = 6;`, produces a compile error. 

To make variables mutable, use the `mut` keyword.

```rust
let mut a = 4;
a = 5; // compiles

let b = 4;
b = 5; // compile error
```

The different types of variables are best found by consulting the [Rust 
tutorial](http://static.rust-lang.org/doc/0.8/tutorial.html#syntax-basics).

A safe way to cast variables is to use the `as` keyword.

```rust
let x = 4u; // x is an unsigned integer
let y = x as i32; // y is x as a 32-bit integer
```

Another example will help clarify this and the previous section. This code 
recursively computes the number of steps in a number's Collatz sequence.

```rust
fn main()
{
	let steps = collatz(10, 0);
	print(format!("{:?}", steps));
}

fn collatz(x: int, steps: int) -> int
{
	if x == 1
	{
		return steps;
	}

	if x%2 == 0
	{
		return collatz(x/2, steps+1);
	}
	else
	{
		return collatz(x*3+1, steps+1);
	}
}
```

There are one or two new things here. The first is the `format!`. The `!` means
that it is a macro, and `format!` is used to print data in human readable form.
It's similar to C's `printf`.

The second new bit is specific to Rust's syntax. `if` statements don't have
parenthesis around their conditionals. However, each `if` statement must have a
body, and that body must be surrounded by braces.

Rust also features a `match` statement. It's an alternative to `if` statements 
and is considered "prettier". The last `if-else` group can be replaced with a 
match statement.

```rust
fn main()
{
	let steps = collatz(10, 0);
	print(format!("{:?}\n", steps));
}

fn collatz(x: int, steps: int) -> int
{
	if x == 1
	{
		return steps;
	}

	match x%2	
	{
		0 => { return collatz(x/2, steps+1); }
		_ => { return collatz(x*3+1, steps+1); }
	}
}
```

The `_` is similar to a `switch` statement's `default` in Java. If nothing
matches the variable, the statement falls through to the `_` case. The Rust
compiler requires an execution path for each possible outcome, and will 
complain if the match conditions are not exhaustive. It's not an oracle though,
 and will throw an error if the `_` is replaced with `1`. (It's better with 
 booleans.)

The following `if-else` statement and `match` statement are equivalent.
```rust
if doSomething
{
	doSomething();
}
else
{
	doNothing();
}

match doSomething
{
	true => { doSomething(); }
	false => { doNothing(); }
	// no _ is needed. The compiler can figure out that this match
	// statement is exhaustive.
}
```

One additional thing to note about `match` statements is that the code for a
case must be surrounded in braces, even if it's empty.

```rust
match x
{
	4 => { print("It's four"); }
	// 5 => print("It's five"); // not valid
	_ => {;}
}
```

Rust vectors (i.e. arrays) are made using `[` and `]`. Vectors made this way 
are put on the stack.

```rust
	let a1 = [1, 2, 3]; // array containing integers
	let b1 = ["hello", "world"]; // array of strings
```

Arrays can also be made using `let array = [x, ..N]`. This makes an array of
size `N` and sets each value to `x`.

```rust
	let c = [0, ..10]; // array of ten 0's
```

Rust has several different types of loops. All Rust loops need to have their
code surrounded in braces (`{`, `}`). All Rust loops work with the `break`
and `continue` keywords, whose meanings are the same as in C++.

The most basic loop is the `loop` keyword. It loops until a `break` is 
encountered.

```rust
	// loops forever
	loop
	{
		println("Hi");
	}
```

```rust
	// loops 10 times
	let mut i = 1;
	loop
	{
		println(format!("{:?}", i));
		i += 1; // Rust doesn't have `++` or `--` operators

		if i > 10 { break; }
	}
```

Rust also has a `while` loop. Its syntax is almost exactly the same as C, C++, 
or Java. The previous loops can easily be rewritten using `while` loops.

```rust
	while true
	{
		println("Hi");
	}
```

```rust
	let mut i = 1;
	while i <= 10 // parentheses could have been used, `while (i <= 10)`
	{
		println(format!("{:?}", i));
		i += 1;
	}
```

Here's a Rust quine combining `while` loops, variables, and arrays. It should 
provide good examples of Rust syntax.

```rust
fn main()
{
	let q = 34u8;
	let p = 44u8;
	let l = [
	"fn main()",
	"{",
	"	let q = 34u8;",
	"	let p = 44u8;",
	"	let l = [",
	"	",
	"	];",
	"	let mut i = 0;",
	"	while i < 5",
	"	{",
	"		println(l[i]);",
	"		i+=1;",
	"	}",
	"	i = 0;",
	"	while i < l.len()",
	"	{",
	"		print(l[5]);",
	"		print((q as char).to_str());",
	"		print(l[i]);",
	"		print((q as char).to_str());",
	"		println((p as char).to_str());",
	"		i+=1;",
	"	}",
	"	i = 6;",
	"	while i < l.len()",
	"	{",
	"		println(l[i]);",
	"		i+=1;",
	"	}",
	"}",
	];
	let mut i = 0;
	while i < 5
	{
		println(l[i]);
		i+=1;
	}
	i = 0;
	while i < l.len()
	{
		print(l[5]);
		print((q as char).to_str());
		print(l[i]);
		print((q as char).to_str());
		println((p as char).to_str());
		i+=1;
	}
	i = 6;
	while i < l.len()
	{
		println(l[i]);
		i+=1;
	}
}
```

Rust `for` loops are different from those in C, C++, and Java. They're more
akin to Java's `for-each` loop. `for` loops work by using an iterator.

We need to use an iterator to loop over elements in a vector. This shows that
vectors come with some additional functionality that other language's arrays
lack.

```rust
	// prints `&1, &2, &3, `
	let nums = [1,2,3];
	for x in nums.iter()
	{
		print(format!("{:?}, ", x));
	}
```

There's a `range(a, b)` function that can be used to loop over a sequential 
set of numbers, `[a,b)`.

```rust
	// prints `0, 1`
	for x in range(0,2)
	{
		print(format!("{:?}, ", x));
	}
```

* * *
[Previous](01.md)	[Next](03.md)