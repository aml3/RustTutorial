<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <link href="css/style.css" rel="stylesheet" type="text/css">
        <link href="css/tabs.css" rel="stylesheet" type="text/css">
        <link href="css/code.css" rel="stylesheet" type="text/css">
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
        <script src="js/tabs.js"></script>
    </head>
    <body>
<title>Getting Started with Rust</title>
<h1 id="Getting_Started:_Variables,_Functions,_and_Syntax" >Getting Started: Variables, Functions, and Syntax</h1>
<br/><table style="border-top: 1px solid #ccc; border-bottom: 1px solid #ccc; width:100%"><tr><td style="width:20%"><a href="toc.html" style="float:left"> Previous </a></td><td style="text-align: center;"><a href="toc.html"> Table of Contents </a></td><td style="width:20%"><a href="incomplete.html" style="float: right"> Next </a></td></tr></table><br/><p>
In this section, we'll be going over the basic syntax of Rust. You'll learn about
variable declarations and mutability, how to work with functions, and some basic
control structures including loops, conditionals, and matching. Finally, we will analyze
a simple program to find
<a href="http://en.wikipedia.org/wiki/Collatz_conjecture">Collatz numbers</a>
that employs the topics in this section.
<h2 id="Variables" >Variables</h2>
<h3 id="Declaration_and_Typing:" >Declaration and Typing:</h3>
Here is a valid variable declaration in Rust:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="src"><pre><span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="m">5</span><span class="p">;</span> 
</pre></div>
</td></tr></table>
</div><p>
There are several things you should notice about this. 
First, the keyword 
<span class="src"><code><span class="k">let</span></code></span>
.
<span class="src"><code><span class="k">let</span></code></span>
 is used to declare local variables in Rust, and must preface every such declaration. 
Second, if you're accustomed to other statically-typed languages, you've probably noticed that there is no explicit statement of type here; instead, the compiler infers that 
<span class="src"><code><span class="n">foo</span></code></span>
 should be an int. 
Rust's compiler is typically very good at correctly inferring types for variables. However, there are times that it draws an incorrect conclusion, usually when the type a variable could be is in some manner ambiguous. We can circumvent this by explicitly telling the compiler what type you want the variable to be, as so: 
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="src"><pre><span class="k">let</span> <span class="n">foo</span><span class="o">:</span> <span class="k">int</span> <span class="o">=</span> <span class="m">5</span><span class="p">;</span>
</pre></div>
</td></tr></table>
</div><p>
Rust's primitive types are similar to those in other C-like languages. There are more details at the 
<a href="http://static.rust-lang.org/doc/0.9/tutorial.html#syntax-basics">official tutorial;</a>
look for "Primitive types and literals".
</p>
<p>
Finally, you should notice that the above declaration uses =, as you would expect, for assignment, and terminates the statement with a semicolon. Operators in Rust are essentially all the same as in languages with which you're familiar, and we'll discuss the difference between statements and expressions (which are not terminated by a semicolon) later in this section. 
To summarize, declarations of local variables in Rust follow the form: 
<div class="src"><pre><span class="k">let</span> <span class="n">name</span><span class="p">[</span><span class="o">:</span> <span class="k">type</span><span class="p">]</span> <span class="p">[</span><span class="o">=</span> <span class="n">value</span><span class="p">];</span>
</pre></div>where the items in brackets are optional.
<h3 id="Mutability:" >Mutability:</h3>
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="src"><pre><span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="m">5</span><span class="p">;</span>
<span class="n">foo</span> <span class="o">=</span> <span class="m">6</span><span class="p">;</span>
</pre></div>
</td></tr></table>
</div><p>
The above code is invalid Rust; it will not compile. Instead, you'll get:
<pre><code>test.rs:3:2: 3:5 <span style="color:red;">error:</span> re-assignment of immutable variable `foo`
test.rs:3   foo = 6;
            <span style="color:red;">^~~</span>
test.rs:2:6: 2:9 <span style="color:green;">note</span>: prior assignment occurs here
test.rs:2   let foo = 5;
                <span style="color:green;">^~~</span>
error: aborting due to previous error
</code></pre>
This is because all Rust local variables are, 
by default, immutable - meaning that you cannot change their assigned value once given.
In other words, variables are not actually variable by default. This will be familiar if
you have experience with functional programming. In order 
to make a mutable local variable, you must introduce another keyword - 
<span class="src"><code><span class="k">mut</span></code></span>
. The following code will work:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="src"><pre><span class="k">let</span> <span class="k">mut</span> <span class="n">foo</span> <span class="o">=</span> <span class="m">5</span><span class="p">;</span>
<span class="n">foo</span> <span class="o">=</span> <span class="m">6</span><span class="p">;</span>
</pre></div>
</td></tr></table>
</div><h3 id="Tuples:" >Tuples:</h3>
<p>
Rust features an additional type named a tuple. Tuples are groupings of values,
similar in appearance but different in function to a list of variables. 
</p>
<p>
Making a tuple is easy. The values to be included are enclosed in parentheses 
and separated by commas. One nice feature is that tuples are heterogeneous; 
we can mix field types.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="src"><pre><span class="k">let</span> <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="m">5.0</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">);</span> 
</pre></div>
</td></tr></table>
</div><p>
There are a few caveats that we need to be wary of:
<ul>
<li>Elements in a tuple are immutable</li>
<li>Tuple fields cannot be accessed directly</li>
<li>A tuple must have at least one field</li>
</ul>
</p>
<h2 id="Conditionals" >Conditionals</h2>
<p>
Rust’s conditionals are very similar to what you’ve probably seen in Java or another 
C-family language, with two slight exceptions. The associated keywords are 
<span class="src"><code><span class="k">if</span></code></span>
,
<span class="src"><code><span class="k">else</span> <span class="k">if</span></code></span>
, and
<span class="src"><code><span class="k">else</span></code></span>
, and are followed by a boolean expression (it must be of type
<span class="src"><code><span class="n">bool</span></code></span>
; no type conversion will take place automatically) in the case of 
<span class="src"><code><span class="k">if</span></code></span>
 and
<span class="src"><code><span class="k">else</span> <span class="k">if</span></code></span>
. The boolean expressions need not be in parentheses, but the body of the conditional 
block must be enclosed in braces. That is, whereas in Java, you could have something like: 
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="src"><pre><span class="k">if</span><span class="o">(</span><span class="n">foo</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span> 
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;it worked&quot;</span><span class="o">);</span>
</pre></div>
</td></tr></table>
</div><p>
the equivalent in Rust of 
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="src"><pre><span class="k">if</span> <span class="n">foo</span> <span class="o">==</span> <span class="m">5</span> 
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;it worked&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>
</div><p>
is illegal. The following is a legal conditional block. Note that the else and 
else if are optional for validity.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="src"><pre><span class="k">if</span> <span class="n">foo</span> <span class="o">==</span> <span class="m">5</span> <span class="p">{</span> 
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;it’s five&quot;</span><span class="p">);</span> 
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">foo</span> <span class="o">==</span> <span class="m">6</span> <span class="p">{</span> 
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;it’s six&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span> 
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;it’s not five or six&quot;</span><span class="p">);</span> 
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h2 id="Pattern_Matching" >Pattern Matching</h2>
<p>
Rather than using a “switch” statement, as you may have seen in other 
languages, Rust uses the 
<span class="src"><code><span class="k">match</span></code></span>
statement. 
<span class="src"><code><span class="k">match</span></code></span>
is like a significantly more powerful and useful switch, and is used fairly 
extensively in a lot of Rust code. You'll run into it frequently, particularly
in the error handling section. Here's an example:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="src"><pre><span class="k">match</span> <span class="n">isOdd</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">true</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Odd&quot;</span><span class="p">),</span> <span class="c1">// Notice the comma</span>
	<span class="k">false</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Even&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
A
<span class="src"><code><span class="k">match</span></code></span>
statement evaluates the first branch with a matching pattern. The pattern is an expression
with the same type as the object being matched. If the object has the same value as one that the pattern
accepts (see below for accepting multiple values with a single match arm), then the corresponding arm
will be evaluated.
</p>
<p>
If we want to include more than one statement in a branch of the 
<span class="src"><code><span class="k">match</span></code></span>
, we have to surround the code in braces. With braces, we don't need a comma, 
but they're allowed.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="src"><pre><span class="k">match</span> <span class="n">isOdd</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">true</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Odd&quot;</span><span class="p">);</span> <span class="m">0</span> <span class="p">}</span>
	<span class="k">false</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Even&quot;</span><span class="p">);</span> <span class="m">1</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
The compiler checks that at least one pattern of the 
<span class="src"><code><span class="k">match</span></code></span>
 expression will always match. When a variable is matched, the patterns must 
completely represent the possible values the variable could hold. This is easy
for booleans; there's just 
<span class="src"><code><span class="k">true</span></code></span>
and
<span class="src"><code><span class="k">false</span></code></span>
. For other types, listing every possible value would be tedious and awful. 
</p>
<p>
To prevent insanity, Rust includes a <code>_</code> that matches everything.
</p>
  <ul class="tabs">
<li><a href="#tab1-1">Rust</a></li>
<li><a href="#tab1-2">Java</a></li>
    </ul>
<div id="tab1-1" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="src"><pre><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="m">4</span><span class="p">;</span>
<span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
	<span class="m">0</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span> <span class="c1">// Do nothing</span>
	<span class="m">4</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">foo</span><span class="p">();</span> <span class="p">}</span> 
	<span class="n">_</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">bar</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// Matches every integer value</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div>					</div>
                
<div id="tab1-2" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="src"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
<span class="k">switch</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">break</span><span class="o">;</span>
	<span class="k">case</span> <span class="mi">4</span><span class="o">:</span> <span class="n">foo</span><span class="o">();</span>
		<span class="k">break</span><span class="o">;</span>
	<span class="k">default</span><span class="o">:</span> <span class="n">bar</span><span class="o">();</span>
		<span class="k">break</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>
</div>					</div><p>
 
<span class="src"><code><span class="k">match</span></code></span>
 can also use simple logical expressions in its arms. For example, 
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="src"><pre><span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
    <span class="m">3</span><span class="o">|</span><span class="m">5</span><span class="o">|</span><span class="m">6</span>  <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;First arm!&quot;</span><span class="p">);</span> <span class="p">}</span>
    <span class="m">10.</span><span class="p">.</span><span class="m">16</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Second arm!&quot;</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">_</span>      <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Default arm!&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
will print "First arm!" if x is 3, 5, or 6, "Second arm!" if x is between 10 and 16, and "Default arm!" otherwise.
</p>
<p>
Pattern matching is used to access tuple values. If we don't care about a value,
we can use <code>_</code> to ignore it.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="src"><pre><span class="k">let</span> <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="m">5.0</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">);</span> 
<span class="k">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">tup</span><span class="p">;</span>
</pre></div>
</td></tr></table>
</div><p>
The <code>_</code> is handy for  
<span class="src"><code><span class="k">match</span></code></span>
statements too.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="src"><pre><span class="k">match</span> <span class="n">status</span> <span class="p">{</span>
	<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Success&quot;</span><span class="p">),</span>
	<span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Pyrrhic victory&quot;</span><span class="p">),</span> <span class="c1">// Any first value matches</span>
	<span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Complete loss&quot;</span><span class="p">)</span> <span class="c1">// Any pair of values will match</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
(note that in this case <code>status</code> would need to be of type
<span class="src"><code><span class="p">(</span><span class="k">int</span><span class="p">,</span> <span class="n">bool</span><span class="p">)</span></code></span>
)
</p>
<p>
 
<span class="src"><code><span class="k">match</span></code></span>
 also allows for "pattern guards" - logical expressions that can be used to further
narrow down what a particular arm selects. For example:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="src"><pre><span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Decreasing&quot;</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Increasing&quot;</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">_</span>              <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Equal&quot;</span><span class="p">)}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
will print correctly the relation between <code>x</code> and <code>y</code>.
</p>
<h3 id="An_Exercise_in_Matching" >An Exercise in Matching</h3>
<p>
To quickly test your comprehension of what you've learned so far, try writing a simple program to do the following:
Given a tuple containing an int and a bool, use a match statement to determine (a) if the bool is true and the int is 
between 20 and 26, (b) if the bool is true and the aforementioned condition isn't true for the int, 
(c) if the int is between 40 and 49 (where the value of the bool doesn't matter), and (d), wherein none of the previous
conditions are true. Print out an appropriate message using <code>println</code> for each case (e.g. for (a), you could print
"True and in range", or something of the sort). Since you haven't learned how to get input yet, just define a variable like this:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="src"><pre><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="m">51</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
</pre></div>
</td></tr></table>
</div><p>
match on it, and manually change its value to test the different branches.
Put your code inside a block of this form, and run "rustc <filename>" to compile it.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Code goes here</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h2 id="Looping" >Looping</h2>
<p>
Rust provides several choices of looping structure, similar to those in C and Java.
In Rust loops, we can use
<span class="src"><code><span class="k">break</span></code></span>
to get out of the loop and 
<span class="src"><code><span class="n">continue</span></code></span>
to skip to the next iteration.
<h3 id="<code_class='src'><span_class='k'>while</span></code>:" ><code class='src'><span class='k'>while</span></code>:</h3>
Like most other languages, a
<span class="src"><code><span class="k">while</span></code></span>
loop iterates until its condition is false. Its condition must be of type bool.
</p>
  <ul class="tabs">
<li><a href="#tab2-1">Rust</a></li>
<li><a href="#tab2-2">Java</a></li>
    </ul>
<div id="tab2-1" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="src"><pre><span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span> <span class="p">{</span> 
	<span class="n">println</span><span class="p">(</span><span class="s">&quot;Hi there&quot;</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">+=</span> <span class="m">1</span><span class="p">;</span> <span class="c1">// Rust doesn&#39;t support ++ or --</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div>					</div>
                
<div id="tab2-2" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="src"><pre><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Hi there&quot;</span><span class="o">);</span>
	<span class="n">i</span><span class="o">++;</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>
</div>					</div><p>
Its syntax is
<div class="src"><pre><span class="k">while</span> <span class="n">condition</span> <span class="p">{</span>
	<span class="optional"><span class="n">code</span></span>
<span class="p">}</span>
</pre></div><h3 id="<code_class='src'><span_class='k'>loop</span></code>:" ><code class='src'><span class='k'>loop</span></code>:</h3>
<span class="src"><code><span class="k">loop</span></code></span>
is syntactic sugar for 
<span class="src"><code><span class="k">while</span> <span class="k">true</span></code></span>
.
</p>
<p>
For completeness, its syntax is
<div class="src"><pre><span class="k">loop</span> <span class="p">{</span>
	<span class="optional"><span class="n">code</span></span>
<span class="p">}</span>
</pre></div><h3 id="<code_class='src'><span_class='k'>for</span></code>:_" ><code class='src'><span class='k'>for</span></code>: </h3>
Rust’s for loop is more akin to Java’s for-each loop than to a traditional 
for loop. It uses an iterator to loop over the items in a variable. 
Since we haven’t covered vectors, for now it’s enough to know that we can 
achieve a traditional for loop by using 
<span class="src"><code><span class="n">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span></code></span>
, which creates a set of integers, <code>[start, end)</code>.
</p>
  <ul class="tabs">
<li><a href="#tab3-1">Rust</a></li>
<li><a href="#tab3-2">Java</a></li>
    </ul>
<div id="tab3-1" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="src"><pre><span class="c1">// Calls foo with 0, 1, ..., 9</span>
<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div>					</div>
                
<div id="tab3-2" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="src"><pre><span class="c1">// Calls foo with 0, 1, ..., 9</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
	<span class="n">foo</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>
</div>					</div><h2 id="Expressions:" >Expressions:</h2>
<p>
Rust’s use of the semicolon may seem confusing when first encountered, but, once
learned  is intuitive and remarkably useful. Essentially, everything that 
doesn’t end with a semicolon is an expression, and everything that does is a 
statement. Expressions have an associated value, whereas statements do not (technically, 
they have a value of nil or void, but for our purposes this is the same as having none.)
You can think of the semicolon in Rust as suppressing the value of an expression, 
turning it into a statement.
</p>
<p>
Almost everything in Rust can be an expression - the only exceptions are declarations.
This allows Rust code to be very nicely concise. For example, an explicit return from a function is not necessary in most cases. 
In general, this use of expressions makes the 
<span class="src"><code><span class="k">return</span></code></span>
 keyword necessary only when you want to leave a function early. Another common use of Rust's
expressions is easy conditional assignment of variables, as a conditional block will have the
value of its last expression:
</p>
  <ul class="tabs">
<li><a href="#tab4-1">Rust</a></li>
<li><a href="#tab4-2">Java</a></li>
    </ul>
<div id="tab4-1" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="src"><pre><span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="m">5</span> <span class="p">{</span>
                <span class="s">&quot;five&quot;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="m">6</span> <span class="p">{</span>
                <span class="s">&quot;six&quot;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
                <span class="s">&quot;neither&quot;</span>
          <span class="p">}</span>
</pre></div>
</td></tr></table>
</div>					</div>
                
<div id="tab4-2" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="src"><pre><span class="n">String</span> <span class="n">foo</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="s">&quot;five&quot;</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">6</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="s">&quot;six&quot;</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">else</span> <span class="o">{</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="s">&quot;neither&quot;</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>
</div>					</div><p>
The same can be done with pattern matching, as, again, the block will have the value of its
last expression:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="src"><pre><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">match</span> <span class="n">y</span> <span class="p">{</span>
    <span class="m">0.</span><span class="p">.</span><span class="m">9</span>    <span class="o">=&gt;</span>  <span class="p">{</span> <span class="s">&quot;Less than 10&quot;</span> <span class="p">}</span>
    <span class="n">_</span>       <span class="o">=&gt;</span>  <span class="p">{</span> <span class="s">&quot;Greater than 10&quot;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h2 id="Functions" >Functions</h2>
<h3 id="Definition_and_Invocation:" >Definition and Invocation:</h3>
<p>
Functions are created by using 
<span class="src"><code><span class="k">fn</span></code></span>
. Like loops, their bodies must be surrounded 
by braces.
Here’s the syntax for a function that accepts no parameters and doesn't return 
anything:
<div class="src"><pre><span class="k">fn</span> <span class="n">name</span><span class="p">()</span> <span class="p">{</span>
	<span class="optional"><span class="n">code</span></span>
<span class="p">}</span>
</pre></div></p>
<p>
And here is an example:
</p>
  <ul class="tabs">
<li><a href="#tab5-1">Rust</a></li>
<li><a href="#tab5-2">Java</a></li>
    </ul>
<div id="tab5-1" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">println</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div>					</div>
                
<div id="tab5-2" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
	<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>
</div>					</div><p>
As expected, this function can be called with 
<span class="src"><code><span class="n">foo</span><span class="p">()</span></code></span>
</p>
<p>
Functions can be declared inside other functions. This means 
that the following is valid Rust:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">fn</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">);</span> <span class="p">}</span>
	<span class="n">bar</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h3 id="Parameters_and_Return_Values:" >Parameters and Return Values:</h3>
<p>
When parameters are given to a function, their types must be specified using
the same syntax that specifies a type during variable declaration, 
<span class="src"><code><span class="n">name</span> <span class="o">:</span><span class="k">type</span></code></span>
.
</p>
  <ul class="tabs">
<li><a href="#tab6-1">Rust</a></li>
<li><a href="#tab6-2">Java</a></li>
    </ul>
<div id="tab6-1" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">rprime_sum</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="k">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="k">int</span><span class="p">,</span> <span class="n">m</span><span class="o">:</span> <span class="k">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">match</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">%</span><span class="n">m</span> <span class="p">{</span>
		<span class="m">0</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Multiple&quot;</span><span class="p">),</span>
		<span class="n">_</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Relatively prime&quot;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div>					</div>
                
<div id="tab6-2" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="src"><pre><span class="kt">void</span> <span class="nf">rprime_sum</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">((</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">)%</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Multiple&quot;</span><span class="o">);</span>
	<span class="k">else</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Relatively prime&quot;</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>
</div>					</div><p>
A return value is specified using <code>-> type</code> after the parameter 
list. To actually return a value, we use Rust's expressions.
</p>
  <ul class="tabs">
<li><a href="#tab7-1">Rust</a></li>
<li><a href="#tab7-2">Java</a></li>
    </ul>
<div id="tab7-1" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span> <span class="p">{</span>
	<span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div>					</div>
                
<div id="tab7-2" class="tabcode">
        <div class="tabbed"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="kt">int</span> <span class="nf">square</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>
</div>					</div><h3 id="Yet_More_Exercise:" >Yet More Exercise:</h3>
<p>
As another check to make sure you're good to go so far, try to implement
<a href="http://c2.com/cgi/wiki?FizzBuzzTest">Fizz Buzz,</a>
as specified on that page. Remember that you'll need to put your code in a main function, as shown above.
<h2 id="Program_1:_Collatz" >Program 1: Collatz</h2>
<h3 id="The_Collatz_Conjecture:" >The Collatz Conjecture:</h3>
The
<a href="http://en.wikipedia.org/wiki/Collatz_conjecture">Collatz Conjecture,</a>
 named after Lothar Collatz, states that, starting from any natural number, it is
possible to reach 1 by following certain rules:
<ol>
    <li> Take n:
        <ul>
            <li> If n is odd, set n = 3n+1.
            <li> Else, if n is even, set n = n/2.
        </ul>
    <li> Repeat the procedure until 1 is reached.
</ol>
</p>
<p>
The conjecture is currently unproven, although it has been shown to hold for numbers up to 5476377146882523136. 
<h3 id="Finding_a_Collatz_Sequence:" >Finding a Collatz Sequence:</h3>
As you might imagine, given the simple nature of the conjecture's rules, it's quite easy to 
find the Collatz sequence for a given number programmatically. The below is Rust code to do just that:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">collatz</span><span class="p">(</span><span class="n">N</span><span class="o">:</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span> <span class="k">return</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">match</span> <span class="n">N</span> <span class="o">%</span> <span class="m">2</span> <span class="p">{</span>
		<span class="m">0</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="m">1</span> <span class="o">+</span> <span class="n">collatz</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="m">2</span><span class="p">)</span> <span class="p">}</span>
		<span class="n">_</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="m">1</span> <span class="o">+</span> <span class="n">collatz</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="m">3</span><span class="o">+</span><span class="m">1</span><span class="p">)</span> <span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
We can use this code in the following program to find the number of Collatz steps for a user-input number:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="src"><pre><span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">os</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">os</span><span class="o">::</span><span class="n">args</span><span class="p">().</span><span class="n">len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="m">2</span> <span class="p">{</span>
		<span class="n">println</span><span class="p">(</span><span class="s">&quot;Error: Please provide a number as argument.&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">from_str</span><span class="o">::&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="o">::</span><span class="n">args</span><span class="p">()[</span><span class="m">1</span><span class="p">]).</span><span class="n">unwrap</span><span class="p">();</span>
	<span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:d} has {:d} Collatz steps&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">collatz</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">collatz</span><span class="p">(</span><span class="n">N</span><span class="o">:</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span> <span class="k">return</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">match</span> <span class="n">N</span> <span class="o">%</span> <span class="m">2</span> <span class="p">{</span>
		<span class="m">0</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="m">1</span> <span class="o">+</span> <span class="n">collatz</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="m">2</span><span class="p">)</span> <span class="p">}</span>
		<span class="n">_</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="m">1</span> <span class="o">+</span> <span class="n">collatz</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="m">3</span><span class="o">+</span><span class="m">1</span><span class="p">)</span> <span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h3 id="Breaking_Down_the_Code:" >Breaking Down the Code:</h3>
<p>
First, let's look at the main function. There are a couple of things at the beginning which you haven't seen thus far
in the tutorial, namely the contents of the first conditional block:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="src"><pre>	<span class="k">if</span> <span class="n">os</span><span class="o">::</span><span class="n">args</span><span class="p">().</span><span class="n">len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="m">2</span> <span class="p">{</span>
		<span class="n">println</span><span class="p">(</span><span class="s">&quot;Error: Please provide a number as argument.&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
We aren't going to worry about the meaning of the <code>os::</code> in the boolean expression of the conditional block just yet;
for now, just know that 
<span class="src"><code><span class="n">os</span><span class="o">::</span><span class="n">args</span><span class="p">().</span><span class="n">len</span><span class="p">()</span></code></span>
 gets the number of command-line arguments passed in. 
<span class="src"><code><span class="n">println</span></code></span>
, as you've probably guessed based on your use of other languages, prints the string argument passed in. 
The conditional block ends with a return statement, which, as we discussed earlier, is being used to prematurely exit the function.
There's only one other thing to notice in the main function (we're ignoring line 9 - just know that it gets the first command line argument, changes it from a string to an int, and assigns that to a variable), and that's the slight variation in line 10's 
<span class="src"><code><span class="n">println</span></code></span>
 statement. Specifically, notice the !, and the arguments being passed in. The ! specifies that the call is to a macro, which
is a kind of language extension in Rust. We'll be going over them in more detail later. In particular, this macro is like <code>printf</code> in C, and takes as its first argument a format string, with the remaining arguments being used to fill the slots of the format string. The syntax Rust uses for its format strings is similar to that of 
<a href="http://docs.python.org/2/library/string.html#format-string-syntax">Python.</a>
</p>
<p>
Moving into the <code>collatz</code> routine, we see the function declaration syntax we discussed above.
<code>collatz</code> takes in an int and returns an int:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">collatz</span><span class="p">(</span><span class="n">N</span><span class="o">:</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span> <span class="k">return</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">match</span> <span class="n">N</span> <span class="o">%</span> <span class="m">2</span> <span class="p">{</span>
		<span class="m">0</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="m">1</span> <span class="o">+</span> <span class="n">collatz</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="m">2</span><span class="p">)</span> <span class="p">}</span>
		<span class="n">_</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="m">1</span> <span class="o">+</span> <span class="n">collatz</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="m">3</span><span class="o">+</span><span class="m">1</span><span class="p">)</span> <span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
The main takeaway from this code is the use of a match block to carry out the actual Collatz conjecture algorithm.
 Notice that we have to have the
<span class="src"><code><span class="n">_</span></code></span>
 arm of the block in order for it to be comprehensive; given this, it makes sense to only have
one other arm (as opposed to two other arms, one for 0 and one for 1).
Finally, notice again that, by not putting semicolons at the end of the calls in each arm of the match
block, we are able to use the value of whichever arm of the block is selected as our return value without
an explicit return statement.
</p>
<h3 id="Final_Exercises:" >Final Exercises:</h3>
<p>
To finish off this section, we have a small programming problem for you to solve. Starting with the above code (also available in a file
<a href="http://aml3.github.io/RustTutorial/code/collatz.rs">here</a>
), make a program that takes as command-line input a single number, representing a number of Collatz steps 
(steps required to reach 1 by following the Collatz procedure), and computes the lowest number (starting from 1) which requires this 
number of Collatz steps. For example, if the number input was 949, your program should output 63,728,127; similarly, if you input 1132, it should output 9,780,657,630 as the lowest number requiring 1132 Collatz steps.
Since these are fairly large numbers, and it might take your code a very long time to reach them
 (unless you use a more advanced technique, such as in some manner memoizing previous results and
efficiently checking to see if you've already found the number of steps remaining from a given number - but I digress)
 you can use the following smaller test cases: For an input of 6, your code should output 10. For an input of 45, it should
output 361. Finally, for an input of 260, it should print 18514.
Bonus points if you can do it using each type of loop in Rust, as well as if you can do it recursively.
</p>
<p>
Ready for more Rust? Head to the next section.
</p>
<br/><table style="border-top: 1px solid #ccc; border-bottom: 1px solid #ccc; width:100%"><tr><td style="width:20%"><a href="toc.html" style="float:left"> Previous </a></td><td style="text-align: center;"><a href="toc.html"> Table of Contents </a></td><td style="width:20%"><a href="incomplete.html" style="float: right"> Next </a></td></tr></table><br/>    </body>
                </html>