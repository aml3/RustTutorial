ptitle Getting Started with Rust
phead 1 Getting Started: Variables, Functions, and Syntax
pnav toc.html 02.html
In this section, we'll be going over the basic syntax of Rust. You'll learn about
variable declarations and mutability, how to work with functions, and some basic
control flow, like loops, conditionals, and matching. Finally, we'll be analyzing
a simple program to find
plink http://en.wikipedia.org/wiki/Collatz_conjecture Collatz numbers
, which will utilize the topics in this section.
phead 2 Variables
phead 3 Declaration and Typing:
scode False {'lang': 'rust'}
codeb
let foo = 5; 
bedoc
The above is a valid variable declaration in Rust. There are several things you should notice about this. 
First, the keyword 
scode False {'lang': 'rust'}
code
let
edoc
.
scode False {'lang': 'rust'}
code
let
edoc
 is used to declare local variables in Rust, and must preface every such declaration. 
Second, if you're accustomed to other statically-typed languages, you've probably noticed that there is no explicit statement of type here; instead, the compiler infers that 
scode False {'lang': 'rust'}
code
foo
edoc
 should be an int. 
Rust's compiler is typically very good at correctly inferring types for variables. However, there are times that it draws an incorrect conclusion, usually when the type a variable could be is in some manner ambiguous. We can circumvent this by explicitly telling the compiler what type you want the variable to be, as so: 
scode False {'lang': 'rust'} 
codeb
let foo: int = 5;
bedoc
Rust's primitive types are essentially what you would expect with a background in C-like languages:

<table style="width: 90%; margin-left: auto; margin-right: auto; text-align: center; border: 1px solid #ccc">
    <tr>
        <td style="width: 30%; border: 1px solid #ccc">
            Integral types:
        </td>
        <td style="border: 1px solid #ccc">
            Signed and unsigned integers (
scode False {'lang': 'rust'}
code
int
edoc
 and 
scode False {'lang': 'rust'}
code
uint
edoc
, respectively), in 8-, 16-, 32-, and 64- bit sizes (
scode False {'lang': 'rust'}
code
i8
edoc
,
scode False {'lang': 'rust'}
code
u8
edoc
, etc.)
        </td>
    </tr>
    <tr>
        <td style="border: 1px solid #ccc">
            Floating point:
        </td>
        <td style="border: 1px solid #ccc">
            32- and 64- bit floating point numbers (
scode False {'lang': 'rust'}
code
f32
edoc
 and 
scode False {'lang': 'rust'}
code
f64
edoc
)
        </td>
    </tr>
    <tr>
        <td style="border: 1px solid #ccc">
            Booleans:
        </td>
        <td style="border: 1px solid #ccc">
scode False {'lang': 'rust'}
code
bool
edoc
, which has values of 
scode False {'lang': 'rust'}
code
true
edoc
 or 
scode False {'lang': 'rust'}
code
false
edoc
.
        </td>
    </tr>
    <tr>
        <td style="border: 1px solid #ccc">
            Characters:
        </td>
        <td style="border: 1px solid #ccc">
scode False {'lang': 'rust'}
code
char
edoc
, a 4-byte Unicode codepoint representation.
        </td>
    </tr>
</table>


Finally, you should notice that the above declaration uses =, as you would expect, for assignment, and terminates the statement with a semicolon. Operators in Rust are essentially all the same as in languages with which you're familiar, and we'll discuss the difference between statements and expressions (which are not terminated by a semicolon) later in this section. 
To summarize, declarations of local variables in Rust follow the form: 
synx
let name`: type` `= value`;
xnys
where the grayed out items are optional.
phead 3 Mutability:
scode False {'lang': 'rust'}
codeb
let foo = 5;
foo = 6;
bedoc
The above code is invalid Rust; it will not compile. This is because all Rust local variables are, 
by default, immutable - meaning that you cannot change their assigned value once given. In order 
to make a mutable local variable, you must introduce another keyword - 
scode False {'lang': 'rust'}
code
mut
edoc
. The following code will work:
scode False {'lang': 'rust'}
codeb
let mut foo = 5;
foo = 6;
bedoc
phead 3 Static Variables:
Rust does have support for static variables; however, as they lead to all manner of trouble,
particularly when dealing with concurrent programs, all static items must be either 
immutable or only used in an unsafe function or block (which will be discussed later). 
Static variables always require a type specification, and are declared with the static keyword, as so: 
scode False {'lang': 'rust'}
codeb
static foo: int = 5;
bedoc

phead 2 Conditionals
Rust’s conditionals are very similar to what you’ve probably seen in Java or another 
C-family language, with two slight exceptions. The associated keywords are 
scode False {'lang': 'rust'} 
code
if
edoc
,
scode False {'lang': 'rust'} 
code
else if
edoc
, and
scode False {'lang': 'rust'} 
code
else
edoc
, and are followed by a boolean expression (it must be of type
scode False {'lang': 'rust'} 
code
bool
edoc
; no type conversion will take place automatically) in the case of 
scode False {'lang': 'rust'} 
code
if
edoc
 and
scode False {'lang': 'rust'} 
code
else if
edoc
. The boolean expressions need not be in parentheses, but the body of the conditional 
block must be enclosed in braces. That is, whereas in Java, you could have something like: 
scode False {'lang': 'java'} 
codeb
if(foo == 5) 
    System.out.println("it worked");
bedoc
the equivalent in Rust:
scode False {'lang': 'rust'}
codeb
if foo == 5 
    println("it worked");
bedoc
is illegal. The following is a legal conditional block; note that the else and 
else if are optional for validity.
scode False {'lang': 'rust'}
codeb
if foo == 5 { 
    println("it’s five"); 
}
else if foo == 6 { 
    println("it’s six");
}
else { 
    println("it’s not five or six"); 
}
bedoc
phead 2 Pattern Matching
Rather than using a “switch” statement, as you may have seen in other 
languages, Rust uses the 
scode False { 'lang' : 'rust' }
code
match 
edoc
statement. 
scode False { 'lang' : 'rust' }
code
match
edoc
is like a significantly more powerful and useful switch, and is used fairly 
extensively in a lot of Rust code. You'll run into it frequently, particularly
in the error handling section.
scode False { 'lang' : 'rust' }
code
match
edoc
works like this:
scode False { 'lang' : 'rust' }
codeb
match isOdd(x) {
	true => println("Odd"), // Notice the comma
	false => println("Even")
}
bedoc
A
scode False { 'lang' : 'rust' }
code
match
edoc
statement evaluates the first branch with a matching pattern.

If we want to include more than one statement in a branch of the 
scode False { 'lang' : 'rust' }
code
match
edoc
, we have to surround the code in braces. With braces, we don't need a comma, 
but they're allowed.
scode False { 'lang' : 'rust' }
codeb
match isOdd(x) {
	true => { println("Odd"); return 0; }
	false => { println("Even"); return 1; }
}
bedoc
The compiler checks to ensure that one branch of the 
scode False { 'lang' : 'rust' }
code
match
edoc
statment always evaluates. When a variable is matched, the patterns must 
completely represent the possible values the variable could hold. This is easy
for booleans; there's just 
scode False { 'lang' : 'rust' }
code
true
edoc
and
scode False { 'lang' : 'rust' }
code
false
edoc
. For other types, listing every possible value would be tedious and awful. 

To prevent insanity, Rust includes a <code>_</code> that matches everything.
scode True {}
rcode
let x = 4;
match x {
	0 => { ; } // Do nothing
	4 => { foo(); } 
	_ => { bar(); } // Matches every integer value
}
edocr
jcode
int x = 4;
switch (x) {
	case 0: break;
	case 4: foo();
		break;
	default: bar();
		break;
}
edocj
phead 3 Tuples:
Rust features an additional type named a tuple. Tuples are groupings of values,
similar in appearance but different in function to a list of variables. 

Making a tuple is easy. The values to be included are enclosed in parentheses 
and separated by commas. One nice feature is that tuples are heterogeneous; 
we can mix field types.
scode False { 'lang' : 'rust' }
codeb
let tup = (4, 5.0, false, "hello"); 
bedoc
There are a few caveats that we need to be wary of:
<ul>
<li>Elements in a tuple are immutable</li>
<li>Tuple fields cannot be accessed directly</li>
<li>A tuple must have at least one field</li>
</ul>
Pattern matching is used to access tuple values. If we don't care about a value,
we can use <code>_</code> to ignore it.
scode False { 'lang' : 'rust' }
codeb
let tup = (4, 5.0, false, "hello"); 
let (a, b, c, _) = tup;
bedoc
The <code>_</code> is handy for  
scode False { 'lang' : 'rust' }
code
match
edoc
statements too.
scode False { 'lang' : 'rust' }
codeb
match status {
	(0, true) => println("Success"),
	(_, true) => println("Pyrrhic victory"), // Any first value matches
	(_, _) => println("Complete loss")
}
bedoc
phead 2 Looping
In Rust loops, we can use
scode False { 'lang' : 'rust' }
code
break
edoc
to get out of the loop and 
scode False { 'lang' : 'rust' }
code
continue
edoc
to skip to the next iteration.
phead 3 <code class='src'><span class='k'>while</span></code>:
Like most other languages, a
scode False { 'lang' : 'rust' }
code
while
edoc
loop iterates until its condition is false. Its condition must be of type bool.
scode True {}
rcode
let mut i = 0;
while i < 10 { 
	println("Hi there");
	i += 1; // Rust doesn't support ++ or --
}
edocr
jcode
int i = 0;
while (i < 10) {
	System.out.println("Hi there");
	i++;
}
edocj
Its syntax is
synx
while condition {
	`code`
}
xnys
phead 3 <code class='src'><span class='k'>loop</span></code>:
scode False { 'lang' : 'rust' }
code
loop
edoc
is syntactic sugar for 
scode False { 'lang' : 'rust' }
code
while true
edoc
.

For completeness, its syntax is
synx
loop {
	`code`
}
xnys
phead 3 <code class='src'><span class='k'>for</span></code>: 
Rust’s for loop is more akin to Java’s for-each loop than to a traditional 
for loop. It uses an iterator to loop over the items in a variable. 
Since we haven’t covered vectors, for now it’s enough to know that we can 
achieve a traditional for loop by using 
scode False { 'lang' : 'rust' }
code
range(start, end)
edoc
, which creates a set of integers, <code>[start, end)</code>.

scode True {}
rcode
// Calls foo with 0, 1, ..., 9
for i in range(0, 10) {
	foo(i);
}
edocr
jcode
// Calls foo with 0, 1, ..., 9
for (int i = 0; i < 10; i++) {
	foo(i);
}
edocj
phead 2 Functions
phead 3 Definition and Invocation:
Functions are created by using 
scode False { 'lang' : 'rust' }
code
fn
edoc
. Like loops, their bodies must be surrounded 
by braces. To make sure we’re on the same page, 
here’s the syntax for a function that accepts no parameters and doesn't return 
anything:
synx
fn name() {
	`code`
}
xnys

And here is an example:
scode True {}
rcode
fn foo() {
	println("foo");
}
edocr
jcode
void foo() {
	System.out.println("foo");
}
edocj
As expected, this function can be called with 
scode False { 'lang' : 'rust' }
code
foo();
edoc

Interestingly, functions can be declared inside other functions. This means 
that the following is valid Rust:
scode False { 'lang' : 'rust' }
codeb
fn foo() {
	fn bar() { println("bar"); }
	bar();
}
bedoc
phead 3 Parameters and Return Values:
When parameters are given to a function, their types must be specified using
the same syntax that specifies a type during variable declaration, 
scode False { 'lang' : 'rust' }
code
name :type
edoc
.
scode True {}
rcode
fn rprime_sum(x: int, y: int, m: int) {
	match (x+y)%m {
		0 => println("Multiple"),
		_ => println("Relatively prime")
	}
}
edocr
jcode
void rprime_sum(int x, int y, int m) {
	if ((x+y)%m == 0)
		System.out.println("Multiple");
	else
		System.out.println("Relatively prime");
}
edocj
A return value is specified using <code>-> type</code> after the parameter 
list. To actually return a value, we use 
scode False { 'lang' : 'rust' }
code
return
edoc
(or an expression, discussed next).
scode True {}
rcode
fn square(x: int) -> int {
	return x*x;
}
edocr
jcode
int square(int x) {
	return x*x;
}
edocj

phead 3 Expressions:
Rust’s use of the semicolon may seem confusing when first encountered, but, once
learned  is intuitive and remarkably useful. Essentially, everything that 
doesn’t end with a semicolon is an expression, and everything that does is a 
statement. Expressions have an associated value, whereas statements do not (technically, 
they have a value of nil or void, but for our purposes this is the same as having none.)
You can think of the semicolon in Rust as suppressing the value of an expression, and 
thereby turning it into a statement.

Almost everything in Rust can be an expression - the only exceptions are declarations.
This allows Rust code to be very nicely concise. For example, as we saw above in the 
section on return values, an explicit return is not necessary in most cases. In general, this
use of expressions makes the 
scode False {'lang': 'rust'}
code
return
edoc
 keyword necessary only when you want to leave a function early. Another common use of Rust's
expressions is easy conditional assignment of variables:
scode True {}
rcode
let foo = if x == 5 {
                "five"
          }
          else if x == 6 {
                "six"
          }
          else {
                "neither"
          }
edocr
jcode
String foo;
if (x == 5) {
    foo = "five";
}
else if (x == 6) {
    foo = "six";
}
else {
    foo = "neither";
}
edocj

phead 2 Collatz
phead 3 The Collatz Conjecture:
The
plink http://en.wikipedia.org/wiki/Collatz_conjecture Collatz Conjecture,
 named after Lothar Collatz, states that, starting from any natural number, it is
possible to reach 1 by following certain rules:
<ol>
    <li> Take n:
        <ul>
            <li> If n is odd, set n = 3n+1.
            <li> Else, if n is even, set n = n/2.
        </ul>
    <li> Repeat the procedure until 1 is reached.
</ol>

The conjecture is currently unproven, although there is evidence that it should be true. 
phead 3 Finding a Collatz Sequence:
As you might imagine, given the simple nature of the conjecture's rules, it's quite easy to 
find the Collatz sequence for a given number programmatically. The below is Rust code to do just that:
scode False {'loc': 'code/collatz.rs', 'lang': 'rust', 'range': False}
phead 3 Breaking Down the Code:
This code uses the topics you've learned in this section, so we'll walk through it and discuss their use.
The first thing to notice is the first two lines:
scode False {'loc': 'code/collatz.rs', 'lang': 'rust', 'range': True, 'start': 1, 'stop': 2}
All Rust programs must begin as such, with a 'main' function. This is much the same as other C-family languages.
As for the second line, note the declaration of
scode False {'lang': 'rust'}
code
i
edoc
 as 
scode False {'lang': 'rust'}
code
mut
edoc
; as discussed in the section on mutability, this is necessary to allow us to be able to
change the value of
scode False {'lang': 'rust'}
code
i
edoc
 later in the code.

The next bit of code should be fairly straightforward. We're calling 
scode False {'lang': 'rust'}
code
println
edoc
, Rust's console output function, and finding the Collatz sequence for the value 1.
However, the next line is a little more interesting:
scode False {'loc': 'code/collatz.rs', 'lang': 'rust', 'range': True, 'start': 7, 'stop': 7}
Note here that we have an exclamation point after the function name. This indicates that we are calling a 
macro (more on these later). For your purposes right now, know that 
scode False {'lang': 'rust'}
code
println!
edoc
is how we do formatted output in Rust - the format string syntax is reminiscent of Python's.
Here, we use 
scode False {'lang': 'rust'}
code
{:?}
edoc
 to indicate that any type passed in will be accepted; later, on line 43, we use 
scode False {'lang': 'rust'}
code
{:d}
edoc
 to indicate that we expect an integer.

We also use the looping constructs discussed earlier; note the use on line 15 of
scode False {'lang': 'rust'}
code
break
edoc
 to exit the infinite loop made with
scode False {'lang': 'rust'}
code
loop
edoc
.

The first of our non-main functions is fairly boring; note only that we use a function
call as an expression (with no semicolon) to return a value rather than an explicit return statement.
scode False {'loc': 'code/collatz.rs', 'lang': 'rust', 'range': True, 'start': 38, 'stop': 40}

The second and final of our non-main functions is slightly more interesting. 
scode False {'loc': 'code/collatz.rs', 'lang': 'rust', 'range': True, 'start': 42, 'stop': 50}
Here, in addition to 
the aforementioned use of a type specifier in
scode False {'lang': 'rust'}
code
println!
edoc
 , we also make use of a match block to carry out the actual Collatz conjecture algorithm.
 Notice that we have to have the
scode False {'lang': 'rust'}
code
_
edoc
 arm of the block in order for it to be comprehensive; given this, it makes sense to only have
one other arm (as opposed to two other arms, one for 0 and one for 1).
Finally, notice again that, by not putting semicolons at the end of the calls in each arm of the match
block, we are able to use the value of whichever arm of the block is selected as our return value, without
an explicit return statement.

Ready for more Rust? Head to the next section.
pnav toc.html 02.html
