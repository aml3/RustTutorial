ptitle Multi-Tasking Maps
phead 1 Multi-Tasking Maps:<br>Structures, Higher-Order Functions, and Tasks
pnav 02.html incomplete.html
This section covers creating and using structs in Rust, making use of higher order functions and traits to create generic functions.  We also introduce tasks, Rust's way of handling multiprocessing, and a simple mechanism for communicating between tasks.  In the following section, we'll cover some of the richer cross-task communication abstractions provided by Rust. 

As a running example, we will use these concepts to build a structure for a simple linked list, a map function which will apply a given function to all elements in the list, and finally use of tasks to make our simple map execute in parallel.

phead 2 Structs and Traits in Rust
phead 3 Rust Structs
A 
scode
struct
edoc
 is Rust's way of packaging data into a structure. It is similar to 
scode
struct
edoc
 in C. A 
scode
struct
edoc
type is defined using:
scode False {'lang': 'rust'}
codeb
struct Name { 
   field1: T1, 
   field2: T2, 
   ... 
}
bedoc
where
scode
T1
edoc
 and 
scode
T2
edoc
 are the types of the preceding fields. 

Note that mutability is not specified in the 
scode
struct
edoc
 type definition. A 
scode
struct 
edoc
 is declared mutable upon creation, and mutability applied to all fields within. 

The following code defines a 
scode
Node
edoc
 for a linked list. The field 
scode
val
edoc
 is an integer, and the 
scode
tail
edoc
 field is either a pointer to the next 
scode
Node
edoc
, or 
scode
None
edoc
 for the last 
scode
Node
edoc
 in the list. 
scode False {'lang': 'rust'}
codeb
struct Node {
    val: int,
    tail: Option<~Node>
}
bedoc
The
scode
tail
edoc
 is an 
scode
Option<~Node>
edoc
, so it either points to an owned 
scode
Node
edoc
, or is
scode
None
edoc
 (an empty List).

The 
scode
type Name = Type;
edoc
construct provides a way to define a new name for a type.  Note that this is just for convenience &mdash; the 
scode
Name
edoce
defined by the 
scode
type
ecod
definition means exactly the same thing to the type checker as the
scode
Type
edoc
it is defined to.  

For example, we can define the
scode
List 
edoc
 type using:
scode
type
edoc
 keyword. 
scode False {'lang': 'rust'}
codeb
type List = Option<~Node>;

struct Node {
   val: int,
   tail: List
}
bedoc

A 
scode
struct
edoc
 is constructed in a similar syntax to how it was defined, with the name of the 
scode
struct
edoc
 followed by braces with the fields defined through the syntax of 
scode
fieldName:value
edoc
. The following code defines one immutable and one mutable 
scode
Node
edoc
. Note that trying to change a field of 
scode
node2
edoc
 would result in a compiler error.

scode False {'lang': 'rust'}
codeb
    let node1 = Node {val:10,  tail: None};
    let mut node2 = Node {val: 10, tail: None};
    node2.val = 15; 
bedoc

For an example of how to create a 
scode
List
edoc
 based on our specification, the below code creates a list of 
scode
n
edoc
 length, where the first 
scode
Node
edoc
 has a 
scode
val
edoc
 of 
scode
x
edoc
, and each subsequent
scode
Node
edoc
 increases this value by one.
code False {'lang': 'rust'}
codeb
fn test_list(n: int, x: int) -> List {
    if n == 0 {
        None
    } else {
        Some(~Node{val: x, tail: test_list(n - 1, x + 1)})
    }
}
bedoc
phead 2 Higher Order Functions
A higher order function is a function which takes a function as an input. This has a lot of power for applying an arbitrary function in a consistent manner to some other input. We will see this completed in a 
scode
map
edoc
 function, which will apply a given function to every element in a given 
scode
List
edoc
.
phead 3 Implementing A High Order Function
The declaration of a higher level function in Rust is similar in syntax to that of a standard function. One of the function paramaters can be another function, though. This input function must have its input and output types defined in the declaration. To use another defined function as the input, the 
scode
extern
edoc
 keyword must precede this. The following code defines a higher level function, 
scode
math(n: int, f: extern fn(int) -> int) -> int
edoc
, which takes an arbitrary function that takes an int input and returns an int, and applies it to a given int, 
scode
n
edoc
. We then show how this is called.

scode False {'lang': 'rust'}
codeb
fn math(n: int, f: extern fn(int) -> int) -> int {
    f(n)
}
fn plustwo(n: int) -> int {
    n + 2
}
fn timestwo(n:int) -> int {
    n*2
}
fn main()
{
    let x = 10;
    let y = math(x, plustwo); //y == 12
    let z = math(x, timestwo); //z == 20
}
bedoc
phead 3 List Mapping
The above example above seems like a more complicated way of simply calling a single function. There are some very useful ways of using higher order functions. One can be used for applying a function to every element in a linked list, for instance, as will be shown in this section.
phead 4 Traits
First, we will apply a 
scode
Map trait
edoc
 to our List. A 
scode
trait
edoc
 in Rust is a way of assuring that an object type employs certain functions. If you are familiar with a Java 
scode
Interface
edoc
, traits are similarly used. A declaration declares the names, inputs, and outputs of all functions that an object must define to make use of a 
scode
trait
edoc
 implementation. Implementing a 
scode
trait
edoc
 is defining these functions within the object implementing the 
scode
trait
edoc
, and is done with the 
scode
impl
edoc
 keyword. We'll see this in the next section. Immediately below is the declaration of a 
scode
Map trait
edoc
. The
scode
mapr
edoc
 function takes in a function and will apply that to all items in a List (that implements this 
scode
trait
edoc
 first), and returns this modified list. This is not defined yet, but will will define it next section.
scode False {'lang': 'rust'}
codeb
trait Map {
    fn mapr(&self, extern fn(int) -> int) -> List;
}
bedoc
phead 4 A List Mapping Function
Now, we will implement the 
scode
Map trait
edoc
 to our 
scode
List type
edoc
. This is done with a block preceded by 
scode
impl Map for List
edoc
. Within this block, we define the 
scode
mapr
edoc
 function in relation to a list. The following implementation should be a nice review of concepts from the first two parts of the tutorial. The only thing we haven't seen thus far is the 
scode
ref
edoc
 keyword. This sets the 
scode
current
edoc
 
scode
Node
edoc
 variable to be bound by reference rather than by value.
scode False {'lang': 'rust'}
codeb
impl Map for List {
    fn mapr(&self, f: fn(int) -> int) -> List {
         match(*self) {
            None => None,
            Some(ref current) => { Some(~Node{ val: f(current.val), 
                                               tail: current.tail.mapr(f) }) },
        } 
    } 
}
bedoc
phead 2 Rust Tasks
phead 3 Task Properties
Rust is described by the developers as a language that concentrates on, amoung other things, safety and concurrency. In order to ensure safe, cocurrent computation, Rust makes use of 
scode
tasks
edoc
. Tasks function like a sort of hybrid of a conventional process and thread. A Rust task is given the abstraction of having its own memory space and registers, like a process, but doesn't have a processes' associated operating system cost. Tasks split computation like threads, however do not share memory, thus preventing race conditions and other such inconsistencies. 
phead 3 Spawning a Task
Tasks are created using the 
scode
spawn(fn())
edoc
 function, which proceeds to create a new task, run the given function, 
scode
fn()
edoc
 within the task, and then close the task. Another way to create a task is throught the 
scode
do
edoc
 keyword. Proceeding a block with 
scode
do spawn
edoc
 will create a new task, run the contents of the block within the task, and then close the task. The following example demonstrates these two methods of task creation.
scode False {'lang': 'rust'}
codeb
fn print_task()
{
    println("Hello, from a task!");
}
fn main()
{
    spawn(print_task);
    do spawn {
        println("Hello, from another task!");
    }
}
bedoc

phead 3 Task Communication
As said earlier, tasks do not share memory, and each task has its own individual memory space. Spawning a task and then trying to access variables from outside the scope of the task itself will result in a compiler error. How does one access outside memory then? This is accomplished through the use of 
scode
Port<T>
edoc
 and 
scode
Chan<T>
edoc
 objects. These can be thought of as a link between a spawned task and its parent (the task which spawned it). These are created as a tuple, demonstrated in the code below. The type of 
scode
<T>
edoc
 is unrestricted, however the 
scode
Port
edoc
 and 
scode
Chan
edoc
 must have matching types, otherwise a compiler error is thrown.

The transfer of values between tasks is accomplished with the 
scode
Chan.send(T)
edoc
 function, which puts a value into the 
scode
(Port<T>, Chan<T>)
edoc
 pair, and the 
scode
Port.recv()
edoc
 function, which returns the value that had been sent by the 
scode
Chan
edoc
. The following spawns a very simple task to call our 
scode
plustwo
edoc
 function, and then send the result back to the parent thread.
scode False {'lang': 'rust'}
codeb
   let (port, chan): (Port<int>, Chan<int>) = Chan::new();
    do spawn {
        let x = 10;
        chan.send(plustwo(x));
    }
    let new_x = port.recv(); //new_x == 12
bedoc

It should be noted that a 
scode
(Port<T>, Chan<T>)
edoc
 pair can only be sent to from a single task. Once 
scode
Chan.send(T)
edoc
 has been called from a specific task, that task owns the channel. Trying to call 
scode
Chan.send(T)
edoc
 from multiple tasks will result in a compile time error. Thus, to send objects back and forth between tasks, two different channels are necessary. The following example does the same as the previous, but receives the value for 
scode
plustwo
edoc
 from the parent task, instead of creating it within the spawned task.
scode False {'lang': 'rust'}
codeb
    let (port1, chan1): (Port<int>, Chan<int>) = Chan::new();
    let (port2, chan2): (Port<int>, Chan<int>) = Chan::new();
    do spawn {
        let x = port2.recv();
        chan1.send(plustwo(x));
    }
    chan2.send(10);
    let new_x = port1.recv(); //new_x == 12
bedoc

Keep in mind that once 
scode
Port.recv()
edoc
 has been called, the task which called it will not continue until a value is sent. This can lead to deadlocking programs if a 
scode
Port.recv()
edoc
 is called at an improper time. 
phead 2 Putting It All Together
The code we have in the previous section for a list mapping function works correctly and will successfully map every element in a list to a given function. You may note, however, that this is done strictly sequentially, and thus has a run time of O(n), where n is the number of elements in the list. This can be done more efficently through paralellizing with tasks. Recall that a call to 
scode
port.recv()
edoc
 will not progress until the corresponding 
scode
chan.send(result)
edoc
 has finished. Because of this, the ordering of the lines after the task has spawned is very important. If 
scode
port.recv()
edoc
 is called prior to calling
scode
mapr
edoc
 on the remainder of the list, 
scode
mapr
edoc
 will not actually be called until the task has completed and sent its result. This would be a serialized runtime, the same as the function without spawning tasks. With proper implementation of multitasking, the runtime of this function is reduced to O(1).

Below is the full implementation of a Rust program with a 
scode
List
edoc
 type created, and a 
scode
map
edoc
 function which will apply a given function to all elements of a given list.

<pre><code>
//Code goes here, will be up soon!
</code></pre>