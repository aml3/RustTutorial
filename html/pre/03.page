ptitle Multi-Tasking Maps
phead 1 Multi-Tasking Maps:<br>Structures, Higher-Order Functions, and Tasks
pnav 02.html incomplete.html
This section covers creating and using structs in Rust, making use of higher order functions and traits to create generic functions.  We also introduce tasks, Rust's way of handling multiprocessing, and a simple mechanism for communicating between tasks.  In the following section, we'll cover some of the richer cross-task communication abstractions provided by Rust. 

As a running example, we will use these concepts to build a structure for a simple linked list, a map function which will apply a given function to all elements in the list, and finally use of tasks to make our simple map execute in parallel.

phead 2 Structs and Traits in Rust
phead 3 Rust Structs
A 
scode
struct
edoc
 is Rust's way of packaging data into a structure. It is similar to 
scode
struct
edoc
 in C. 

phead 4 Defining Structs

A 
scode
struct
edoc
type is defined using:
scode False {'lang': 'rust'}
codeb
struct Name { 
   field1: T1, 
   field2: T2, 
   ... 
}
bedoc
where
scode
T1
edoc
 and 
scode
T2
edoc
 are the types of the preceding fields. 

Note that mutability is not specified in the 
scode
struct
edoc
 type definition. A 
scode
struct 
edoc
 is declared mutable upon creation, and mutability applied to all fields within. 

The following code defines a 
scode
Node
edoc
 for a linked list. The field 
scode
val
edoc
 is an integer, and the 
scode
tail
edoc
 field is either a pointer to the next 
scode
Node
edoc
, or 
scode
None
edoc
 for the last 
scode
Node
edoc
 in the list. 
scode False {'lang': 'rust'}
codeb
struct Node {
    val: int,
    tail: Option<~Node>
}
bedoc
The
scode
tail
edoc
 is an 
scode
Option<~Node>
edoc
, so it either points to an owned 
scode
Node
edoc
, or is
scode
None
edoc
 (an empty List).

The 
scode
type Name = Type;
edoc
construct provides a way to define a new name for a type.  Note that this is just for convenience &mdash; the 
scode
Name
edoc
defined by the 
scode
type
edoc
definition means exactly the same thing to the type checker as the
scode
Type
edoc
it is defined to.  

For example, we can define the
scode
List 
edoc
 type using:
scode
type
edoc
 keyword. 
scode False {'lang': 'rust'}
codeb
type List = Option<~Node>;

struct Node {
   val: int,
   tail: List
}
bedoc

phead 4 Constructing Structs

A 
scode
struct
edoc
 is constructed in a similar syntax to how it was defined, with the name of the 
scode
struct
edoc
 followed by braces with the fields defined using
scode
fieldName:value
edoc
. 

The following code defines one immutable and one mutable 
scode
Node
edoc
: 
scode False {'lang': 'rust'}
codeb
    let node1 = Node {val:10,  tail: None};
    let mut node2 = Node {val: 10, tail: None};
    node2.val = 15; 
bedoc

The mutability qualifier applies all the fields in the struct.  Trying to change a field of 
scode
node1
edoc
 would result in a compiler error.

For an example, the code below creates a list of 
scode
n
edoc
 elements:
scode False {'lang': 'rust'}
codeb
fn construct_list(n: int, x: int) -> List {
    if n == 0 {
        None
    } else {
        Some(~Node{val: x, tail: construct_list(n - 1, x + 1)})
    }
}
bedoc

<div class="exercise">
<b>Exercise 3.1.</b> Define a 
scode
Tree
edoc
type that can be used to represent a tree where each node has an 
scode
int
edoc
value and a vector of children nodes.
</div>

<div class="exercise">

<b>Exercise 3.2.</b> Define a function that prints out all the elements in a 
scode
Tree 
edoc
 (as you defined it in the previous exercise).
</div>

phead 2 Higher-Order Functions

A higher-order function is a function which operates on other functions.
We can have functions that take other functions as inputs, as well as
functions that create and return new functions as their output.
Higher-order functions provide a lot of power for concisely and very
generally describe computations.  By the end of this section, you'll be
able to write a single function that can do all of the things in the
previous set of exercises!

phead 4 Functions as Parameters

A parameter can have function type, just like any other type.  The type
of a function includes the types of its inputs and the type of its output.  

For example, 
scode False {'lang': 'rust'}
codeb
fn twice(n: int, f: |int| -> int) -> int {
    f(f(n))
}
bedoc
defines a function that takes two inputs, the second of which is a function.  The syntax, 
scode
|arg1, arg2, ...| -> res
edoc
(with vertical bars around a list of parameter types) specifies a function that takes the 
scode
argn
edoc
types as inputs and returns a value of type
scode
res
edoc
.

Here's an example using 
scode
twice
edoc
:

scode False {'lang': 'rust'}
codeb
fn successor(n: int) -> int { n + 1 }
fn double(n:int) -> int { n * 2 }

fn main()
{
    println!("Result: {:d}", twice(twice(1, successor), double));
}
bedoc
The result is (((1 + 1) + 1) * 2) * 2 = 12.

phead 4 Functions as Results

It would be a lot more useful if 
scode
twice
edoc
didn't take the integer as one of its inputs, but instead returned a function.  For example, we would like to be able to do:
scode False {'lang': 'rust'}
codeb
    let square = twice(double);
bedoc
to define a squaring function.  

We can do this by defining a function that returns a function:
scode False {'lang': 'rust'}
codeb
fn twice(f: proc(int) -> int) -> (proc(int) -> int) {
    proc(n: int) { f(f(n)) }
}
bedoc

Now, 
scode
twice
edoc
is a function that take a function as its input (we use 
scode
proc(int) -> int
edoc
here to describe the input function, and need to use 
scode
proc(int) ->int
edoc
instead of
scode
|int| -> int
edoc
because of Rust's lifetime rules.   (Note that the way we defined this, we can only use the returned function once.)  

We can use
scode
twice
edoc
like this:
scode False {'lang': 'rust'}
codeb
fn main()
{
    let hexaple = twice(twice(double));
    println!("Result: {:d}", hexaple(2)); // 32
}
bedoc

<div class="exercise">
<b>Exercise 3.3.</b>  Define a 
scode
compose
edoc
function that takes as inputs two functions and outputs a function that composes the two input functions.  Both of the input functions and the returned function should have type
scode
proc(int) -> int
edoc
.  You should be able to use your
scode
compose
edoc
function to define
scode
   let sixthpower = compose(cube, square)
edoc
where 
scode
cube
edoc
and
scode
square
edoc
are functions that compute the cube and square of an int input respectively.
</div>

<div class="exercise">
<b>Exercise 3.4.</b>

</div>

phead 2 Traits

The above examples hopefully give you a sense of the power of
higher-order functions, but perhaps not how they would be useful in
typical code.  Next, we'll see how higher-order functions can be used to
provide generic functions for manipulating our 
scode
List 
edoc
type.

First, we introduce <em>traits</em> which provide a way of defining a
set of methods.

TODO

 above seems like a more complicated way of simply calling a single function. There are some very useful ways of using higher order functions. One can be used for applying a function to every element in a linked list, for instance, as will be shown in this section.

First, we will apply a 
scode
Map trait
edoc
 to our List. A 
scode
trait
edoc
 in Rust is a way of assuring that an object type employs certain functions. If you are familiar with a Java 
scode
Interface
edoc
, traits are similarly used. A declaration declares the names, inputs, and outputs of all functions that an object must define to make use of a 
scode
trait
edoc
 implementation. Implementing a 
scode
trait
edoc
 is defining these functions within the object implementing the 
scode
trait
edoc
, and is done with the 
scode
impl
edoc
 keyword. We'll see this in the next section. Immediately below is the declaration of a 
scode
Map trait
edoc
. The
scode
mapr
edoc
 function takes in a function and will apply that to all items in a List (that implements this 
scode
trait
edoc
 first), and returns this modified list. This is not defined yet, but will will define it next section.
scode False {'lang': 'rust'}
codeb
trait Map {
    fn mapr(&self, extern fn(int) -> int) -> List;
}
bedoc
phead 4 A List Mapping Function
Now, we will implement the 
scode
Map trait
edoc
 to our 
scode
List type
edoc
. This is done with a block preceded by 
scode
impl Map for List
edoc
. Within this block, we define the 
scode
mapr
edoc
 function in relation to a list. The following implementation should be a nice review of concepts from the first two parts of the tutorial. The only thing we haven't seen thus far is the 
scode
ref
edoc
 keyword. This sets the 
scode
current
edoc
 
scode
Node
edoc
 variable to be bound by reference rather than by value.
scode False {'lang': 'rust'}
codeb
impl Map for List {
    fn mapr(&self, f: fn(int) -> int) -> List {
         match(*self) {
            None => None,
            Some(ref current) => { Some(~Node{ val: f(current.val), 
                                               tail: current.tail.mapr(f) }) },
        } 
    } 
}
bedoc
phead 2 Rust Tasks
phead 3 Task Properties
Rust is described by the developers as a language that concentrates on, amoung other things, safety and concurrency. In order to ensure safe, cocurrent computation, Rust makes use of 
scode
tasks
edoc
. Tasks function like a sort of hybrid of a conventional process and thread. A Rust task is given the abstraction of having its own memory space and registers, like a process, but doesn't have a processes' associated operating system cost. Tasks split computation like threads, however do not share memory, thus preventing race conditions and other such inconsistencies. 
phead 3 Spawning a Task
Tasks are created using the 
scode
spawn(fn())
edoc
 function, which proceeds to create a new task, run the given function, 
scode
fn()
edoc
 within the task, and then close the task. Another way to create a task is throught the 
scode
do
edoc
 keyword. Proceeding a block with 
scode
do spawn
edoc
 will create a new task, run the contents of the block within the task, and then close the task. The following example demonstrates these two methods of task creation.
scode False {'lang': 'rust'}
codeb
fn print_task()
{
    println("Hello, from a task!");
}
fn main()
{
    spawn(print_task);
    do spawn {
        println("Hello, from another task!");
    }
}
bedoc

phead 3 Task Communication
As said earlier, tasks do not share memory, and each task has its own individual memory space. Spawning a task and then trying to access variables from outside the scope of the task itself will result in a compiler error. How does one access outside memory then? This is accomplished through the use of 
scode
Port<T>
edoc
 and 
scode
Chan<T>
edoc
 objects. These can be thought of as a link between a spawned task and its parent (the task which spawned it). These are created as a tuple, demonstrated in the code below. The type of 
scode
<T>
edoc
 is unrestricted, however the 
scode
Port
edoc
 and 
scode
Chan
edoc
 must have matching types, otherwise a compiler error is thrown.

The transfer of values between tasks is accomplished with the 
scode
Chan.send(T)
edoc
 function, which puts a value into the 
scode
(Port<T>, Chan<T>)
edoc
 pair, and the 
scode
Port.recv()
edoc
 function, which returns the value that had been sent by the 
scode
Chan
edoc
. The following spawns a very simple task to call our 
scode
plustwo
edoc
 function, and then send the result back to the parent thread.
scode False {'lang': 'rust'}
codeb
   let (port, chan): (Port<int>, Chan<int>) = Chan::new();
    do spawn {
        let x = 10;
        chan.send(plustwo(x));
    }
    let new_x = port.recv(); //new_x == 12
bedoc

It should be noted that a 
scode
(Port<T>, Chan<T>)
edoc
 pair can only be sent to from a single task. Once 
scode
Chan.send(T)
edoc
 has been called from a specific task, that task owns the channel. Trying to call 
scode
Chan.send(T)
edoc
 from multiple tasks will result in a compile time error. Thus, to send objects back and forth between tasks, two different channels are necessary. The following example does the same as the previous, but receives the value for 
scode
plustwo
edoc
 from the parent task, instead of creating it within the spawned task.
scode False {'lang': 'rust'}
codeb
    let (port1, chan1): (Port<int>, Chan<int>) = Chan::new();
    let (port2, chan2): (Port<int>, Chan<int>) = Chan::new();
    do spawn {
        let x = port2.recv();
        chan1.send(plustwo(x));
    }
    chan2.send(10);
    let new_x = port1.recv(); //new_x == 12
bedoc

Keep in mind that once 
scode
Port.recv()
edoc
 has been called, the task which called it will not continue until a value is sent. This can lead to deadlocking programs if a 
scode
Port.recv()
edoc
 is called at an improper time. 
phead 2 Putting It All Together
The code we have in the previous section for a list mapping function works correctly and will successfully map every element in a list to a given function. You may note, however, that this is done strictly sequentially, and thus has a run time of O(n), where n is the number of elements in the list. This can be done more efficently through paralellizing with tasks. Recall that a call to 
scode
port.recv()
edoc
 will not progress until the corresponding 
scode
chan.send(result)
edoc
 has finished. Because of this, the ordering of the lines after the task has spawned is very important. If 
scode
port.recv()
edoc
 is called prior to calling
scode
mapr
edoc
 on the remainder of the list, 
scode
mapr
edoc
 will not actually be called until the task has completed and sent its result. This would be a serialized runtime, the same as the function without spawning tasks. With proper implementation of multitasking, the runtime of this function is reduced to O(1).

Below is the full implementation of a Rust program with a 
scode
List
edoc
 type created, and a 
scode
map
edoc
 function which will apply a given function to all elements of a given list.
scode False {'lang': 'rust'}
codeb
struct Node {
    val: int,
    tail: Option<~Node>
}
type List = Option<~Node>;
fn test_list(n: int, x: int) -> List {
    if n == 0 {
        None
    } else {
        Some(~Node{val: x, tail: test_list(n - 1, x + 1)})
    }
}
trait Map {
    fn mapr(&self, extern fn(int) -> int) -> List;
}
impl Map for List {
    fn mapr(&self, f: fn(int) -> int) -> List {
         match(*self) {
            None => None,
            Some(ref current) => { 
                let (port, chan) : (Port<int>, Chan<int>) = Chan::new();
                let currentval = current.val;
                do spawn {
                    let result = f(currentval);
                    chan.send(result);
                }
                let newtail = current.tail.mapr(f);
                let newval = port.recv();
                Some(~Node{ val: newval, tail: newtail }) },
        } 
    } 
}
bedoc
 