ptitle Tasks
phead 1 Tasks and Communication

phead 2 Task Properties

Rust is described by the developers as a language that concentrates on, amoung other things, safety and concurrency. In order to ensure safe, cocurrent computation, Rust makes use of <em>tasks</em>. 

A Rust task is an abstraction that has its own memory space and
registers, like a process, but doesn't have a processes' associated
operating system cost. Tasks split computation like threads, however do
not share memory, thus preventing implicit data races and other
perplexing bugs that occur when multiple threads access and modify the
same data.

phead 3 Spawning a Task
Tasks are created using the 
scode
spawn(fn())
edoc
 function, which creates a new task and executs the input function, 
scode
fn()
edoc
 in that task.  After the function completes, the task is terminated. 

Another way to create a task is throught the 
scode
do
edoc
 keyword. Proceeding a block with 
scode
do spawn
edoc
 will create a new task, run the contents of the block within the task, and then close the task. The following example demonstrates these two methods of task creation.
scode False {'lang': 'rust'}
codeb
fn print_task()
{
    println("Hello, from a task!");
}
fn main()
{
    spawn(print_task);
    do spawn {
        println("Hello, from another task!");
    }
}
bedoc

phead 3 Task Communication
As said earlier, tasks do not share memory, and each task has its own individual memory space. Spawning a task and then trying to access variables from outside the scope of the task itself will result in a compiler error. How does one access outside memory then? This is accomplished through the use of 
scode
Port<T>
edoc
 and 
scode
Chan<T>
edoc
 objects. These can be thought of as a link between a spawned task and its parent (the task which spawned it). These are created as a tuple, demonstrated in the code below. The type of 
scode
<T>
edoc
 is unrestricted, however the 
scode
Port
edoc
 and 
scode
Chan
edoc
 must have matching types, otherwise a compiler error is thrown.

The transfer of values between tasks is accomplished with the 
scode
Chan.send(T)
edoc
 function, which puts a value into the 
scode
(Port<T>, Chan<T>)
edoc
 pair, and the 
scode
Port.recv()
edoc
 function, which returns the value that had been sent by the 
scode
Chan
edoc
. The following spawns a very simple task to call our 
scode
plustwo
edoc
 function, and then send the result back to the parent thread.
scode False {'lang': 'rust'}
codeb
   let (port, chan): (Port<int>, Chan<int>) = Chan::new();
    do spawn {
        let x = 10;
        chan.send(plustwo(x));
    }
    let new_x = port.recv(); //new_x == 12
bedoc

It should be noted that a 
scode
(Port<T>, Chan<T>)
edoc
 pair can only be sent to from a single task. Once 
scode
Chan.send(T)
edoc
 has been called from a specific task, that task owns the channel. Trying to call 
scode
Chan.send(T)
edoc
 from multiple tasks will result in a compile time error. Thus, to send objects back and forth between tasks, two different channels are necessary. The following example does the same as the previous, but receives the value for 
scode
plustwo
edoc
 from the parent task, instead of creating it within the spawned task.
scode False {'lang': 'rust'}
codeb
    let (port1, chan1): (Port<int>, Chan<int>) = Chan::new();
    let (port2, chan2): (Port<int>, Chan<int>) = Chan::new();
    do spawn {
        let x = port2.recv();
        chan1.send(plustwo(x));
    }
    chan2.send(10);
    let new_x = port1.recv(); //new_x == 12
bedoc

Keep in mind that once 
scode
Port.recv()
edoc
 has been called, the task which called it will not continue until a value is sent. This can lead to deadlocking programs if a 
scode
Port.recv()
edoc
 is called at an improper time. 
phead 2 Putting It All Together
The code we have in the previous section for a list mapping function works correctly and will successfully map every element in a list to a given function. You may note, however, that this is done strictly sequentially, and thus has a run time of O(n), where n is the number of elements in the list. This can be done more efficently through paralellizing with tasks. Recall that a call to 
scode
port.recv()
edoc
 will not progress until the corresponding 
scode
chan.send(result)
edoc
 has finished. Because of this, the ordering of the lines after the task has spawned is very important. If 
scode
port.recv()
edoc
 is called prior to calling
scode
mapr
edoc
 on the remainder of the list, 
scode
mapr
edoc
 will not actually be called until the task has completed and sent its result. This would be a serialized runtime, the same as the function without spawning tasks. With proper implementation of multitasking, the runtime of this function is reduced to O(1).

Below is the full implementation of a Rust program with a 
scode
List
edoc
 type created, and a 
scode
map
edoc
 function which will apply a given function to all elements of a given list.
scode False {'lang': 'rust'}
codeb
struct Node {
    val: int,
    tail: Option<~Node>
}
type List = Option<~Node>;
fn test_list(n: int, x: int) -> List {
    if n == 0 {
        None
    } else {
        Some(~Node{val: x, tail: test_list(n - 1, x + 1)})
    }
}
trait Map {
    fn mapr(&self, extern fn(int) -> int) -> List;
}
impl Map for List {
    fn mapr(&self, f: fn(int) -> int) -> List {
         match(*self) {
            None => None,
            Some(ref current) => { 
                let (port, chan) : (Port<int>, Chan<int>) = Chan::new();
                let currentval = current.val;
                do spawn {
                    let result = f(currentval);
                    chan.send(result);
                }
                let newtail = current.tail.mapr(f);
                let newval = port.recv();
                Some(~Node{ val: newval, tail: newtail }) },
        } 
    } 
}
bedoc
 
