<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <link href="css/style.css" rel="stylesheet" type="text/css">
        <link href="css/tabs.css" rel="stylesheet" type="text/css">
        <link href="css/code.css" rel="stylesheet" type="text/css">
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
        <script src="js/tabs.js"></script>
    </head>
    <body>
<title>Multi-Tasking Maps</title>
<h1 id="Multi-Tasking_Maps:<br>Structures,_Higher-Order_Functions,_and_Tasks" >Multi-Tasking Maps:<br>Structures, Higher-Order Functions, and Tasks</h1>
<br/><table style="border-top: 1px solid #ccc; border-bottom: 1px solid #ccc; width:100%"><tr><td style="width:20%"><a href="02.html" style="float:left"> Previous </a></td><td style="text-align: center;"><a href="toc.html"> Table of Contents </a></td><td style="width:20%"><a href="incomplete.html" style="float: right"> Next </a></td></tr></table><br/><p>
This section covers creating and using structs in Rust, making use of higher order functions and traits to create generic functions.  We also introduce tasks, Rust's way of handling multiprocessing, and a simple mechanism for communicating between tasks.  In the following section, we'll cover some of the richer cross-task communication abstractions provided by Rust. 
</p>
<p>
As a running example, we will use these concepts to build a structure for a simple linked list, a map function which will apply a given function to all elements in the list, and finally use of tasks to make our simple map execute in parallel.
</p>
<h2 id="Structs_and_Traits_in_Rust" >Structs and Traits in Rust</h2>
<h3 id="Rust_Structs" >Rust Structs</h3>
<p>
A 
<span class="src"><code><span class="k">struct</span></code></span>
 is Rust's way of packaging data into a structure. It is similar to 
<span class="src"><code><span class="k">struct</span></code></span>
 in C. 
</p>
<h4 id="Defining_Structs" >Defining Structs</h4>
<p>
A 
<span class="src"><code><span class="k">struct</span></code></span>
type is defined using:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="src"><pre><span class="k">struct</span> <span class="n">Name</span> <span class="p">{</span> 
   <span class="n">field1</span><span class="o">:</span> <span class="n">T1</span><span class="p">,</span> 
   <span class="n">field2</span><span class="o">:</span> <span class="n">T2</span><span class="p">,</span> 
   <span class="p">...</span> 
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
where
<span class="src"><code><span class="n">T1</span></code></span>
 and 
<span class="src"><code><span class="n">T2</span></code></span>
 are the types of the preceding fields. 
</p>
<p>
Note that mutability is not specified in the 
<span class="src"><code><span class="k">struct</span></code></span>
 type definition. A 
<span class="src"><code><span class="k">struct</span></code></span>
 is declared mutable upon creation, and mutability applied to all fields within. 
</p>
<p>
The following code defines a 
<span class="src"><code><span class="n">Node</span></code></span>
 for a linked list. The field 
<span class="src"><code><span class="n">val</span></code></span>
 is an integer, and the 
<span class="src"><code><span class="n">tail</span></code></span>
 field is either a pointer to the next 
<span class="src"><code><span class="n">Node</span></code></span>
, or 
<span class="src"><code><span class="n">None</span></code></span>
 for the last 
<span class="src"><code><span class="n">Node</span></code></span>
 in the list. 
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="src"><pre><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">val</span><span class="o">:</span> <span class="k">int</span><span class="p">,</span>
    <span class="n">tail</span><span class="o">:</span> <span class="n">Option</span><span class="o">&lt;~</span><span class="n">Node</span><span class="o">&gt;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
The
<span class="src"><code><span class="n">tail</span></code></span>
 is an 
<span class="src"><code><span class="n">Option</span><span class="o">&lt;~</span><span class="n">Node</span><span class="o">&gt;</span></code></span>
, so it either points to an owned 
<span class="src"><code><span class="n">Node</span></code></span>
, or is
<span class="src"><code><span class="n">None</span></code></span>
 (an empty List).
</p>
<p>
The 
<span class="src"><code><span class="k">type</span> <span class="n">Name</span> <span class="o">=</span> <span class="n">Type</span><span class="p">;</span></code></span>
construct provides a way to define a new name for a type.  Note that this is just for convenience &mdash; the 
<span class="src"><code><span class="n">Name</span></code></span>
defined by the 
<span class="src"><code><span class="k">type</span></code></span>
definition means exactly the same thing to the type checker as the
<span class="src"><code><span class="n">Type</span></code></span>
it is defined to.  
</p>
<p>
For example, we can define the
<span class="src"><code><span class="n">List</span></code></span>
 type using:
<span class="src"><code><span class="k">type</span></code></span>
 keyword. 
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="src"><pre><span class="k">type</span> <span class="n">List</span> <span class="o">=</span> <span class="n">Option</span><span class="o">&lt;~</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
   <span class="n">val</span><span class="o">:</span> <span class="k">int</span><span class="p">,</span>
   <span class="n">tail</span><span class="o">:</span> <span class="n">List</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h4 id="Constructing_Structs" >Constructing Structs</h4>
<p>
A 
<span class="src"><code><span class="k">struct</span></code></span>
 is constructed in a similar syntax to how it was defined, with the name of the 
<span class="src"><code><span class="k">struct</span></code></span>
 followed by braces with the fields defined using
<span class="src"><code><span class="n">fieldName</span><span class="o">:</span><span class="n">value</span></code></span>
. 
</p>
<p>
The following code defines one immutable and one mutable 
<span class="src"><code><span class="n">Node</span></code></span>
: 
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="n">node1</span> <span class="o">=</span> <span class="n">Node</span> <span class="p">{</span><span class="n">val</span><span class="o">:</span><span class="m">10</span><span class="p">,</span>  <span class="n">tail</span><span class="o">:</span> <span class="n">None</span><span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">node2</span> <span class="o">=</span> <span class="n">Node</span> <span class="p">{</span><span class="n">val</span><span class="o">:</span> <span class="m">10</span><span class="p">,</span> <span class="n">tail</span><span class="o">:</span> <span class="n">None</span><span class="p">};</span>
    <span class="n">node2</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="m">15</span><span class="p">;</span> 
</pre></div>
</td></tr></table>
</div><p>
The mutability qualifier applies all the fields in the struct.  Trying to change a field of 
<span class="src"><code><span class="n">node1</span></code></span>
 would result in a compiler error.
</p>
<p>
For an example, the code below creates a list of 
<span class="src"><code><span class="n">n</span></code></span>
 elements:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">construct_list</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="k">int</span><span class="p">,</span> <span class="n">x</span><span class="o">:</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">None</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">Some</span><span class="p">(</span><span class="o">~</span><span class="n">Node</span><span class="p">{</span><span class="n">val</span><span class="o">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">tail</span><span class="o">:</span> <span class="n">construct_list</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="m">1</span><span class="p">)})</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
<div class="exercise">
<b>Exercise 3.1.</b> Define a 
<span class="src"><code><span class="n">Tree</span></code></span>
type that can be used to represent a tree where each node has an 
<span class="src"><code><span class="k">int</span></code></span>
value and a vector of children nodes.
</div>
</p>
<p>
<div class="exercise">
</p>
<p>
<b>Exercise 3.2.</b> Define a function that prints out all the elements in a 
<span class="src"><code><span class="n">Tree</span></code></span>
 (as you defined it in the previous exercise).
</div>
</p>
<h2 id="Higher-Order_Functions" >Higher-Order Functions</h2>
<p>
A higher-order function is a function which operates on other functions.
We can have functions that take other functions as inputs, as well as
functions that create and return new functions as their output.
Higher-order functions provide a lot of power for concisely and very
generally describe computations.  By the end of this section, you'll be
able to write a single function that can do all of the things in the
previous set of exercises!
</p>
<h4 id="Functions_as_Parameters" >Functions as Parameters</h4>
<p>
A parameter can have function type, just like any other type.  The type
of a function includes the types of its inputs and the type of its output.  
</p>
<p>
For example, 
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">twice</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="k">int</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="o">|</span><span class="k">int</span><span class="o">|</span> <span class="o">-&gt;</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
defines a function that takes two inputs, the second of which is a function.  The syntax, 
<span class="src"><code><span class="o">|</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="p">...</span><span class="o">|</span> <span class="o">-&gt;</span> <span class="n">res</span></code></span>
(with vertical bars around a list of parameter types) specifies a function that takes the 
<span class="src"><code><span class="n">argn</span></code></span>
types as inputs and returns a value of type
<span class="src"><code><span class="n">res</span></code></span>
.
</p>
<p>
Here's an example using 
<span class="src"><code><span class="n">twice</span></code></span>
:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">successor</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span> <span class="p">{</span> <span class="n">n</span> <span class="o">+</span> <span class="m">1</span> <span class="p">}</span>
<span class="k">fn</span> <span class="n">double</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span> <span class="p">{</span> <span class="n">n</span> <span class="o">*</span> <span class="m">2</span> <span class="p">}</span>

<span class="k">fn</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Result: {:d}&quot;</span><span class="p">,</span> <span class="n">twice</span><span class="p">(</span><span class="n">twice</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">successor</span><span class="p">),</span> <span class="n">double</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
The result is (((1 + 1) + 1) * 2) * 2 = 12.
</p>
<h4 id="Functions_as_Results" >Functions as Results</h4>
<p>
It would be a lot more useful if 
<span class="src"><code><span class="n">twice</span></code></span>
didn't take the integer as one of its inputs, but instead returned a function.  For example, we would like to be able to do:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="n">square</span> <span class="o">=</span> <span class="n">twice</span><span class="p">(</span><span class="n">double</span><span class="p">);</span>
</pre></div>
</td></tr></table>
</div><p>
to define a squaring function.  
</p>
<p>
We can do this by defining a function that returns a function:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">twice</span><span class="p">(</span><span class="n">f</span><span class="o">:</span> <span class="n">proc</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">proc</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">proc</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="k">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
Now, 
<span class="src"><code><span class="n">twice</span></code></span>
is a function that take a function as its input (we use 
<span class="src"><code><span class="n">proc</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span></code></span>
here to describe the input function, and need to use 
<span class="src"><code><span class="n">proc</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span><span class="k">int</span></code></span>
instead of
<span class="src"><code><span class="o">|</span><span class="k">int</span><span class="o">|</span> <span class="o">-&gt;</span> <span class="k">int</span></code></span>
because of Rust's lifetime rules.   (Note that the way we defined this, we can only use the returned function once.)  
</p>
<p>
We can use
<span class="src"><code><span class="n">twice</span></code></span>
like this:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">hexaple</span> <span class="o">=</span> <span class="n">twice</span><span class="p">(</span><span class="n">twice</span><span class="p">(</span><span class="n">double</span><span class="p">));</span>
    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Result: {:d}&quot;</span><span class="p">,</span> <span class="n">hexaple</span><span class="p">(</span><span class="m">2</span><span class="p">));</span> <span class="c1">// 32</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
<div class="exercise">
<b>Exercise 3.3.</b>  Define a 
<span class="src"><code><span class="n">compose</span></code></span>
function that takes as inputs two functions and outputs a function that composes the two input functions.  Both of the input functions and the returned function should have type
<span class="src"><code><span class="n">proc</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span></code></span>
.  You should be able to use your
<span class="src"><code><span class="n">compose</span></code></span>
function to define
<span class="src"><code>   <span class="k">let</span> <span class="n">sixthpower</span> <span class="o">=</span> <span class="n">compose</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">square</span><span class="p">)</span></code></span>
where 
<span class="src"><code><span class="n">cube</span></code></span>
and
<span class="src"><code><span class="n">square</span></code></span>
are functions that compute the cube and square of an int input respectively.
</div>
</p>
<p>
<div class="exercise">
<b>Exercise 3.4.</b>
</p>
<p>
</div>
</p>
<h3 id="List_Mapping" >List Mapping</h3>
<p>
The above example above seems like a more complicated way of simply calling a single function. There are some very useful ways of using higher order functions. One can be used for applying a function to every element in a linked list, for instance, as will be shown in this section.
<h4 id="Traits" >Traits</h4>
First, we will apply a 
<span class="src"><code><span class="n">Map</span> <span class="k">trait</span></code></span>
 to our List. A 
<span class="src"><code><span class="k">trait</span></code></span>
 in Rust is a way of assuring that an object type employs certain functions. If you are familiar with a Java 
<span class="src"><code><span class="n">Interface</span></code></span>
, traits are similarly used. A declaration declares the names, inputs, and outputs of all functions that an object must define to make use of a 
<span class="src"><code><span class="k">trait</span></code></span>
 implementation. Implementing a 
<span class="src"><code><span class="k">trait</span></code></span>
 is defining these functions within the object implementing the 
<span class="src"><code><span class="k">trait</span></code></span>
, and is done with the 
<span class="src"><code><span class="k">impl</span></code></span>
 keyword. We'll see this in the next section. Immediately below is the declaration of a 
<span class="src"><code><span class="n">Map</span> <span class="k">trait</span></code></span>
. The
<span class="src"><code><span class="n">mapr</span></code></span>
 function takes in a function and will apply that to all items in a List (that implements this 
<span class="src"><code><span class="k">trait</span></code></span>
 first), and returns this modified list. This is not defined yet, but will will define it next section.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="k">trait</span> <span class="n">Map</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">mapr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">,</span> <span class="k">extern</span> <span class="k">fn</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h4 id="A_List_Mapping_Function" >A List Mapping Function</h4>
<p>
Now, we will implement the 
<span class="src"><code><span class="n">Map</span> <span class="k">trait</span></code></span>
 to our 
<span class="src"><code><span class="n">List</span> <span class="k">type</span></code></span>
. This is done with a block preceded by 
<span class="src"><code><span class="k">impl</span> <span class="n">Map</span> <span class="k">for</span> <span class="n">List</span></code></span>
. Within this block, we define the 
<span class="src"><code><span class="n">mapr</span></code></span>
 function in relation to a list. The following implementation should be a nice review of concepts from the first two parts of the tutorial. The only thing we haven't seen thus far is the 
<span class="src"><code><span class="k">ref</span></code></span>
 keyword. This sets the 
<span class="src"><code><span class="n">current</span></code></span>
 
<span class="src"><code><span class="n">Node</span></code></span>
 variable to be bound by reference rather than by value.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="src"><pre><span class="k">impl</span> <span class="n">Map</span> <span class="k">for</span> <span class="n">List</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">mapr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="k">fn</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span> <span class="p">{</span>
         <span class="k">match</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">None</span> <span class="o">=&gt;</span> <span class="n">None</span><span class="p">,</span>
            <span class="n">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">current</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">Some</span><span class="p">(</span><span class="o">~</span><span class="n">Node</span><span class="p">{</span> <span class="n">val</span><span class="o">:</span> <span class="n">f</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">val</span><span class="p">),</span> 
                                               <span class="n">tail</span><span class="o">:</span> <span class="n">current</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">mapr</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">})</span> <span class="p">},</span>
        <span class="p">}</span> 
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h2 id="Rust_Tasks" >Rust Tasks</h2>
<h3 id="Task_Properties" >Task Properties</h3>
<p>
Rust is described by the developers as a language that concentrates on, amoung other things, safety and concurrency. In order to ensure safe, cocurrent computation, Rust makes use of 
<span class="src"><code><span class="n">tasks</span></code></span>
. Tasks function like a sort of hybrid of a conventional process and thread. A Rust task is given the abstraction of having its own memory space and registers, like a process, but doesn't have a processes' associated operating system cost. Tasks split computation like threads, however do not share memory, thus preventing race conditions and other such inconsistencies. 
<h3 id="Spawning_a_Task" >Spawning a Task</h3>
Tasks are created using the 
<span class="src"><code><span class="n">spawn</span><span class="p">(</span><span class="k">fn</span><span class="p">())</span></code></span>
 function, which proceeds to create a new task, run the given function, 
<span class="src"><code><span class="k">fn</span><span class="p">()</span></code></span>
 within the task, and then close the task. Another way to create a task is throught the 
<span class="src"><code><span class="k">do</span></code></span>
 keyword. Proceeding a block with 
<span class="src"><code><span class="k">do</span> <span class="n">spawn</span></code></span>
 will create a new task, run the contents of the block within the task, and then close the task. The following example demonstrates these two methods of task creation.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">print_task</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello, from a task!&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">spawn</span><span class="p">(</span><span class="n">print_task</span><span class="p">);</span>
    <span class="k">do</span> <span class="n">spawn</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello, from another task!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h3 id="Task_Communication" >Task Communication</h3>
<p>
As said earlier, tasks do not share memory, and each task has its own individual memory space. Spawning a task and then trying to access variables from outside the scope of the task itself will result in a compiler error. How does one access outside memory then? This is accomplished through the use of 
<span class="src"><code><span class="n">Port</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></span>
 and 
<span class="src"><code><span class="n">Chan</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></span>
 objects. These can be thought of as a link between a spawned task and its parent (the task which spawned it). These are created as a tuple, demonstrated in the code below. The type of 
<span class="src"><code><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></span>
 is unrestricted, however the 
<span class="src"><code><span class="n">Port</span></code></span>
 and 
<span class="src"><code><span class="n">Chan</span></code></span>
 must have matching types, otherwise a compiler error is thrown.
</p>
<p>
The transfer of values between tasks is accomplished with the 
<span class="src"><code><span class="n">Chan</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code></span>
 function, which puts a value into the 
<span class="src"><code><span class="p">(</span><span class="n">Port</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span></code></span>
 pair, and the 
<span class="src"><code><span class="n">Port</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span></code></span>
 function, which returns the value that had been sent by the 
<span class="src"><code><span class="n">Chan</span></code></span>
. The following spawns a very simple task to call our 
<span class="src"><code><span class="n">plustwo</span></code></span>
 function, and then send the result back to the parent thread.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="src"><pre>   <span class="k">let</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">chan</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="n">Port</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">Chan</span><span class="o">::</span><span class="n">new</span><span class="p">();</span>
    <span class="k">do</span> <span class="n">spawn</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="m">10</span><span class="p">;</span>
        <span class="n">chan</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">plustwo</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">new_x</span> <span class="o">=</span> <span class="n">port</span><span class="p">.</span><span class="n">recv</span><span class="p">();</span> <span class="c1">//new_x == 12</span>
</pre></div>
</td></tr></table>
</div><p>
It should be noted that a 
<span class="src"><code><span class="p">(</span><span class="n">Port</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span></code></span>
 pair can only be sent to from a single task. Once 
<span class="src"><code><span class="n">Chan</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code></span>
 has been called from a specific task, that task owns the channel. Trying to call 
<span class="src"><code><span class="n">Chan</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code></span>
 from multiple tasks will result in a compile time error. Thus, to send objects back and forth between tasks, two different channels are necessary. The following example does the same as the previous, but receives the value for 
<span class="src"><code><span class="n">plustwo</span></code></span>
 from the parent task, instead of creating it within the spawned task.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">chan1</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="n">Port</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">Chan</span><span class="o">::</span><span class="n">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">port2</span><span class="p">,</span> <span class="n">chan2</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="n">Port</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">Chan</span><span class="o">::</span><span class="n">new</span><span class="p">();</span>
    <span class="k">do</span> <span class="n">spawn</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">port2</span><span class="p">.</span><span class="n">recv</span><span class="p">();</span>
        <span class="n">chan1</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">plustwo</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">chan2</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">new_x</span> <span class="o">=</span> <span class="n">port1</span><span class="p">.</span><span class="n">recv</span><span class="p">();</span> <span class="c1">//new_x == 12</span>
</pre></div>
</td></tr></table>
</div><p>
Keep in mind that once 
<span class="src"><code><span class="n">Port</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span></code></span>
 has been called, the task which called it will not continue until a value is sent. This can lead to deadlocking programs if a 
<span class="src"><code><span class="n">Port</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span></code></span>
 is called at an improper time. 
<h2 id="Putting_It_All_Together" >Putting It All Together</h2>
    </body>
                </html>