<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <link href="css/style.css" rel="stylesheet" type="text/css">
        <link href="css/tabs.css" rel="stylesheet" type="text/css">
        <link href="css/code.css" rel="stylesheet" type="text/css">
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
        <script src="js/tabs.js"></script>
    </head>
    <body>
<title>Multi-Tasking Maps</title>
<h1 id="Multi-Tasking_Maps:_Structures,_Higher_Order_Functions,_and_Tasks" >Multi-Tasking Maps: Structures, Higher Order Functions, and Tasks</h1>
<br/><table style="border-top: 1px solid #ccc; border-bottom: 1px solid #ccc; width:100%"><tr><td style="width:20%"><a href="02.html" style="float:left"> Previous </a></td><td style="text-align: center;"><a href="toc.html"> Table of Contents </a></td><td style="width:20%"><a href="incomplete.html" style="float: right"> Next </a></td></tr></table><br/><p>
The third section of this tutorial involves creating and using structs in Rust, making use of higher order functions and traits to create generic functions, and tasks, Rust's way of handling multiprocessing. We will use these concepts to build a structure for a simple linked list, a map function which will apply a given function to all elements in the list, and finally use of tasks to run this mapping in parallel.
</p>
<h2 id="Structs_and_Traits_in_Rust" >Structs and Traits in Rust</h2>
<h3 id="Rust_Structs" >Rust Structs</h3>
<p>
A 
<span class="src"><code><span class="k">struct</span></code></span>
 is Rust's way of creating a structure. These function nearly identically to a 
<span class="src"><code><span class="k">struct</span></code></span>
 in C. A 
<span class="src"><code><span class="k">struct</span></code></span>
is defined before its construction by using the syntax 
<span class="src"><code><span class="k">struct</span> <span class="n">Name</span> <span class="p">{</span> <span class="n">field1</span><span class="o">:</span> <span class="n">T1</span><span class="p">,</span> <span class="n">field2</span><span class="o">:</span> <span class="n">T2</span> <span class="p">[,</span> <span class="p">...]</span> <span class="p">}</span></code></span>
where
<span class="src"><code><span class="n">T1</span></code></span>
 and 
<span class="src"><code><span class="n">T2</span></code></span>
 are the type of the preceding fields. Note that mutability is not specified when the 
<span class="src"><code><span class="k">struct</span></code></span>
 definition. A 
<span class="src"><code><span class="k">struct</span></code></span>
 is declared mutable upon creation, and mutability applied to all fields within. 
</p>
<p>
The following code defines a 
<span class="src"><code><span class="n">Node</span></code></span>
 for a linked list. The field 
<span class="src"><code><span class="n">val</span></code></span>
 is an integer, and the 
<span class="src"><code><span class="n">tail</span></code></span>
 field is either a pointer to the next 
<span class="src"><code><span class="n">Node</span></code></span>
, or 
<span class="src"><code><span class="n">None</span></code></span>
 for the last 
<span class="src"><code><span class="n">Node</span></code></span>
 in the list. We also define the 
<span class="src"><code><span class="n">List</span> <span class="k">type</span></code></span>
 using the 
<span class="src"><code><span class="k">type</span></code></span>
 keyword. This 
<span class="src"><code><span class="n">List</span></code></span>
 is an 
<span class="src"><code><span class="n">Option</span><span class="o">&lt;~</span><span class="n">Node</span><span class="o">&gt;</span></code></span>
, so a 
<span class="src"><code><span class="n">List</span></code></span>
 either points to a 
<span class="src"><code><span class="n">Node</span></code></span>
 pointer (the head of the list), or 
<span class="src"><code><span class="n">None</span></code></span>
 (an empty List);
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="src"><pre><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">val</span><span class="o">:</span> <span class="k">int</span><span class="p">,</span>
    <span class="n">tail</span><span class="o">:</span> <span class="n">Option</span><span class="o">&lt;~</span><span class="n">Node</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">List</span> <span class="o">=</span> <span class="n">Option</span><span class="o">&lt;~</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</td></tr></table>
</div><p>
A 
<span class="src"><code><span class="k">struct</span></code></span>
 is constructed in a similar syntax to how it was defined, with the name of the 
<span class="src"><code><span class="k">struct</span></code></span>
 followed by braces with the fields defined through the syntax of 
<span class="src"><code><span class="n">fieldName</span><span class="o">:</span><span class="n">value</span></code></span>
. The following code defines one immutable and one mutable 
<span class="src"><code><span class="n">Node</span></code></span>
. Note that trying to change a field of 
<span class="src"><code><span class="n">node2</span></code></span>
 would result in a compiler error.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="n">node1</span> <span class="o">=</span> <span class="n">Node</span> <span class="p">{</span><span class="n">val</span><span class="o">:</span><span class="m">10</span><span class="p">,</span>  <span class="n">tail</span><span class="o">:</span> <span class="n">None</span><span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">node2</span> <span class="o">=</span> <span class="n">Node</span> <span class="p">{</span><span class="n">val</span><span class="o">:</span> <span class="m">10</span><span class="p">,</span> <span class="n">tail</span><span class="o">:</span> <span class="n">None</span><span class="p">};</span>
    <span class="n">node2</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="m">15</span><span class="p">;</span> 
</pre></div>
</td></tr></table>
</div><p>
For an example of how to create a 
<span class="src"><code><span class="n">List</span></code></span>
 based on our specification, the below code creates a list of 
<span class="src"><code><span class="n">n</span></code></span>
 length, where the first 
<span class="src"><code><span class="n">Node</span></code></span>
 has a 
<span class="src"><code><span class="n">val</span></code></span>
 of 
<span class="src"><code><span class="n">x</span></code></span>
, and each subsequent
<span class="src"><code><span class="n">Node</span></code></span>
 increases this value by one.
code False {'lang': 'rust'}
codeb
fn test_list(n: int, x: int) -> List {
    if n == 0 {
        None
    } else {
        Some(~Node{val: x, tail: test_list(n - 1, x + 1)})
    }
}
bedoc
<h2 id="Higher_Order_Functions" >Higher Order Functions</h2>
A higher order function is a function which takes a function as an input. This has a lot of power for applying an arbitrary function in a consistent manner to some other input. We will see this completed in a 
<span class="src"><code><span class="n">map</span></code></span>
 function, which will apply a given function to every element in a given 
<span class="src"><code><span class="n">List</span></code></span>
.
<h3 id="Implementing_A_High_Order_Function" >Implementing A High Order Function</h3>
The declaration of a higher level function in Rust is similar in syntax to that of a standard function. One of the function paramaters can be another function, though. This input function must have its input and output types defined in the declaration. To use another defined function as the input, the 
<span class="src"><code><span class="k">extern</span></code></span>
 keyword must precede this. The following code defines a higher level function, 
<span class="src"><code><span class="n">math</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="k">int</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="k">extern</span> <span class="k">fn</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span></code></span>
, which takes an arbitrary function that takes an int input and returns an int, and applies it to a given int, 
<span class="src"><code><span class="n">n</span></code></span>
. We then show how this is called.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">math</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="k">int</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="k">extern</span> <span class="k">fn</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="n">plustwo</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">+</span> <span class="m">2</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="n">timestwo</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span> <span class="p">{</span>
    <span class="n">n</span><span class="o">*</span><span class="m">2</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="m">10</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">math</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">plustwo</span><span class="p">);</span> <span class="c1">//y == 12</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">math</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timestwo</span><span class="p">);</span> <span class="c1">//z == 20</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h3 id="List_Mapping" >List Mapping</h3>
<p>
The above example above seems like a more complicated way of simply calling a single function. There are some very useful ways of using higher order functions. One can be used for applying a function to every element in a linked list, for instance, as will be shown in this section.
<h4 id="Traits" >Traits</h4>
First, we will apply a 
<span class="src"><code><span class="n">Map</span> <span class="k">trait</span></code></span>
 to our List. A 
<span class="src"><code><span class="k">trait</span></code></span>
 in Rust is a way of assuring that an object type employs certain functions. If you are familiar with a Java 
<span class="src"><code><span class="n">Interface</span></code></span>
, traits are similarly used. A declaration declares the names, inputs, and outputs of all functions that an object must define to make use of a 
<span class="src"><code><span class="k">trait</span></code></span>
 implementation. Implementing a 
<span class="src"><code><span class="k">trait</span></code></span>
 is defining these functions within the object implementing the 
<span class="src"><code><span class="k">trait</span></code></span>
, and is done with the 
<span class="src"><code><span class="k">impl</span></code></span>
 keyword. We'll see this in the next section. Immediately below is the declaration of a 
<span class="src"><code><span class="n">Map</span> <span class="k">trait</span></code></span>
. The
<span class="src"><code><span class="n">mapr</span></code></span>
 function takes in a function and will apply that to all items in a List (that implements this 
<span class="src"><code><span class="k">trait</span></code></span>
 first), and returns this modified list. This is not defined yet, but will will define it next section.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="k">trait</span> <span class="n">Map</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">mapr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">,</span> <span class="k">extern</span> <span class="k">fn</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h4 id="A_List_Mapping_Function" >A List Mapping Function</h4>
<p>
Now, we will implement the 
<span class="src"><code><span class="n">Map</span> <span class="k">trait</span></code></span>
 to our 
<span class="src"><code><span class="n">List</span> <span class="k">type</span></code></span>
. This is done with a block preceded by 
<span class="src"><code><span class="k">impl</span> <span class="n">Map</span> <span class="k">for</span> <span class="n">List</span></code></span>
. Within this block, we define the 
<span class="src"><code><span class="n">mapr</span></code></span>
 function in relation to a list. The following implementation should be a nice review of concepts from the first two parts of the tutorial. The only thing we haven't seen thus far is the 
<span class="src"><code><span class="k">ref</span></code></span>
 keyword. This sets the 
<span class="src"><code><span class="n">current</span></code></span>
 
<span class="src"><code><span class="n">Node</span></code></span>
 variable to be bound by reference rather than by value.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="src"><pre><span class="k">impl</span> <span class="n">Map</span> <span class="k">for</span> <span class="n">List</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">mapr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="k">fn</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span> <span class="p">{</span>
         <span class="k">match</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">None</span> <span class="o">=&gt;</span> <span class="n">None</span><span class="p">,</span>
            <span class="n">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">current</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">Some</span><span class="p">(</span><span class="o">~</span><span class="n">Node</span><span class="p">{</span> <span class="n">val</span><span class="o">:</span> <span class="n">f</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">val</span><span class="p">),</span> 
                                               <span class="n">tail</span><span class="o">:</span> <span class="n">current</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">mapr</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">})</span> <span class="p">},</span>
        <span class="p">}</span> 
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h2 id="Rust_Tasks" >Rust Tasks</h2>
<h3 id="Task_Properties" >Task Properties</h3>
<p>
Rust is described by the developers as a language that concentrates on, amoung other things, safety and concurrency. In order to ensure safe, cocurrent computation, Rust makes use of 
<span class="src"><code><span class="n">tasks</span></code></span>
. Tasks function like a sort of hybrid of a conventional process and thread. A Rust task is given the abstraction of having its own memory space and registers, like a process, but doesn't have a processes' associated operating system cost. Tasks split computation like threads, however do not share memory, thus preventing race conditions and other such inconsistencies. 
<h3 id="Spawning_a_Task" >Spawning a Task</h3>
Tasks are created using the 
<span class="src"><code><span class="n">spawn</span><span class="p">(</span><span class="k">fn</span><span class="p">())</span></code></span>
 function, which proceeds to create a new task, run the given function, 
<span class="src"><code><span class="k">fn</span><span class="p">()</span></code></span>
 within the task, and then close the task. Another way to create a task is throught the 
<span class="src"><code><span class="k">do</span></code></span>
 keyword. Proceeding a block with 
<span class="src"><code><span class="k">do</span> <span class="n">spawn</span></code></span>
 will create a new task, run the contents of the block within the task, and then close the task. The following example demonstrates these two methods of task creation.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">print_task</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello, from a task!&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">spawn</span><span class="p">(</span><span class="n">print_task</span><span class="p">);</span>
    <span class="k">do</span> <span class="n">spawn</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello, from another task!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h3 id="Task_Communication" >Task Communication</h3>
<p>
As said earlier, tasks do not share memory, and each task has its own individual memory space. Spawning a task and then trying to access variables from outside the scope of the task itself will result in a compiler error. How does one access outside memory then? This is accomplished through the use of 
<span class="src"><code><span class="n">Port</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></span>
 and 
<span class="src"><code><span class="n">Chan</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></span>
 objects. These can be thought of as a link between a spawned task and its parent (the task which spawned it). These are created as a tuple, demonstrated in the code below. The type of 
<span class="src"><code><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></span>
 is unrestricted, however the 
<span class="src"><code><span class="n">Port</span></code></span>
 and 
<span class="src"><code><span class="n">Chan</span></code></span>
 must have matching types, otherwise a compiler error is thrown.
</p>
<p>
The transfer of values between tasks is accomplished with the 
<span class="src"><code><span class="n">Chan</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code></span>
 function, which puts a value into the 
<span class="src"><code><span class="p">(</span><span class="n">Port</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span></code></span>
 pair, and the 
<span class="src"><code><span class="n">Port</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span></code></span>
 function, which returns the value that had been sent by the 
<span class="src"><code><span class="n">Chan</span></code></span>
. The following spawns a very simple task to call our 
<span class="src"><code><span class="n">plustwo</span></code></span>
 function, and then send the result back to the parent thread.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="src"><pre>   <span class="k">let</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">chan</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="n">Port</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">Chan</span><span class="o">::</span><span class="n">new</span><span class="p">();</span>
    <span class="k">do</span> <span class="n">spawn</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="m">10</span><span class="p">;</span>
        <span class="n">chan</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">plustwo</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">new_x</span> <span class="o">=</span> <span class="n">port</span><span class="p">.</span><span class="n">recv</span><span class="p">();</span> <span class="c1">//new_x == 12</span>
</pre></div>
</td></tr></table>
</div><p>
It should be noted that a 
<span class="src"><code><span class="p">(</span><span class="n">Port</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span></code></span>
 pair can only be sent to from a single task. Once 
<span class="src"><code><span class="n">Chan</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code></span>
 has been called from a specific task, that task owns the channel. Trying to call 
<span class="src"><code><span class="n">Chan</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code></span>
 from multiple tasks will result in a compile time error. Thus, to send objects back and forth between tasks, two different channels are necessary. The following example does the same as the previous, but receives the value for 
<span class="src"><code><span class="n">plustwo</span></code></span>
 from the parent task, instead of creating it within the spawned task.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="p">(</span><span class="n">port1</span><span class="p">,</span> <span class="n">chan1</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="n">Port</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">Chan</span><span class="o">::</span><span class="n">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">port2</span><span class="p">,</span> <span class="n">chan2</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="n">Port</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Chan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">Chan</span><span class="o">::</span><span class="n">new</span><span class="p">();</span>
    <span class="k">do</span> <span class="n">spawn</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">port2</span><span class="p">.</span><span class="n">recv</span><span class="p">();</span>
        <span class="n">chan1</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">plustwo</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">chan2</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">new_x</span> <span class="o">=</span> <span class="n">port1</span><span class="p">.</span><span class="n">recv</span><span class="p">();</span> <span class="c1">//new_x == 12</span>
</pre></div>
</td></tr></table>
</div><p>
Keep in mind that once 
<span class="src"><code><span class="n">Port</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span></code></span>
 has been called, the task which called it will not continue until a value is sent. This can lead to deadlocking programs if a 
<span class="src"><code><span class="n">Port</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span></code></span>
 is called at an improper time. 
<h2 id="Putting_It_All_Together" >Putting It All Together</h2>
    </body>
                </html>