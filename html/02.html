<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <link href="css/style.css" rel="stylesheet" type="text/css">
        <link href="css/tabs.css" rel="stylesheet" type="text/css">
        <link href="css/code.css" rel="stylesheet" type="text/css">
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
        <script src="js/tabs.js"></script>
    </head>
    <body>
<title>Starting to Corrode</title>
<h1 id="Starting_to_Corrode:<br>Pointers,_Memory,_Strings,_and_I/O" >Starting to Corrode:<br>Pointers, Memory, Strings, and I/O</h1>
<p>
This section of the tutorial introduces one of the "rustiest" aspects of Rust: memory management.  
</p>
<p>
Rust provides memory references in a way that is quite different from other languages you may be familiar with, and it requires some effort to understand, but provide the big advantage of providing both explicit control and safety. We'll also cover strings and vectors, file and user I/O, and basic error handling in Rust. At the end of this section, you'll write a simple encryption program that employs many of the new concepts.
</p>
<h2 id="Memory_Management" >Memory Management</h2>
<h3 id="Boxes" >Boxes</h3>
<p>
The <em>box</em> in Rust is the fundamental abstraction of memory. Any pointer or reference in Rust, be it to an 
<span class="src"><code><span class="k">int</span></code></span>
or a complicated 
<span class="src"><code><span class="k">struct</span></code></span>
will be a pointer to a box. Because Rust is designed to emphasize safety, any allocated memory in Rust is <em>boxed</em>, and thus any box can be thought of as simply a chunk of memory. 
<h3 id="Pointer_Types" >Pointer Types</h3>
Rust provides two main pointer types: the <em>owned</em> pointer (indicated by the tilde:
<span class="src"><code><span class="o">~</span></code></span>
) and the <em>borrowed</em> reference (denoted with ampersand: 
<span class="src"><code><span class="o">&amp;</span></code></span>
). Both kinds of pointers point to a box, and the pointer types are orthogonal to the type of data the box contains. For example,
<span class="src"><code><span class="o">~</span><span class="p">[</span><span class="o">&amp;</span><span class="k">str</span><span class="p">]</span></code></span>
is a owned reference to a vector of borrowed strings.
</p>
<p>
Similarly, dereferencing a Rust pointer is done with the star operator ( 
<span class="src"><code><span class="o">*</span></code></span>
 ). The next section on ownership will go into more detail on the usage and interaction of both of these.
<div class="note">
Note: Legacy Rust code (before 0.9) also has a "managed pointer" represented by the 
<span class="src"><code><span class="o">@</span></code></span>
 which was automatically managed (garbage collected). As of Rust 0.9, this syntax is deprecated, however it is planned to be reintroduced in future releases. These added a deal of simplicity to pointer management, however other pointer types could be used with more efficency.  Automatically managed pointers may be implemented as library types.
</div>
</p>
<h3 id="Ownership" >Ownership</h3>
<p>
In Rust, there is a notion of <em>ownership</em> of an object.  The owner of an
object, which could be a variable that refers to that object, manages
the object's lifetime (that is, when its memory is allocated and
reclaimed).  Programmers do not have to explicitly allocated and
deallocate storage.  Rather, it is done by the Rust compiler and runtime
based on how the object references are used.
</p>
<h4 id="Owned_Boxes" >Owned Boxes</h4>
<p>
A declaration of an owned (
<span class="src"><code><span class="o">~</span></code></span>
) pointer can be thought of as giving the declared variable ownership of the box.  What does this mean in code? The following block works as anticipated, printing out "10".
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">~</span><span class="m">10</span><span class="p">;</span>
    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:d}&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</td></tr></table>
</div><p>
However the following block gives a compilation error:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">~</span><span class="m">10</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:d}&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</td></tr></table>
</div><p>
<pre><code>tut2.rs:3:23: 3:24 <span style="color:red;">error:</span> use of moved value: `x`
tut2.rs:3     println!("{:d}", *x);
</code></pre>
The error message is a bit unclear, but what it is reporting is a violation of ownership rules.  When we create the owned box of 
<span class="src"><code><span class="o">~</span><span class="m">10</span></code></span>
, that box is owned by the variable
<span class="src"><code><span class="n">x</span></code></span>
. The initialization,
<span class="src"><code><span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span></code></span>
assigns the <em>pointer</em> to y. Because of Rust's emphasis on safety this is not allowed: it creates two references to an owned box.  
</p>
<p>
In other languages, such as C and Java, there are no restrictions on pointer sharing.  We could do, <!-- markup do distinguish C/Rust code? -->
<span class="src"><code>    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="m">3</span><span class="p">;</span></code></span>
thus changing the value of
<span class="src"><code><span class="o">*</span><span class="n">x</span></code></span>
through the alias.  With Rust, the assignment, 
<span class="src"><code><span class="n">y</span> <span class="o">=</span> <span class="n">x</span></code></span>
<em>transfers</em> ownership of the box 
<span class="src"><code><span class="n">x</span></code></span>
refers to from the 
<span class="src"><code><span class="n">x</span></code></span>
reference to the 
<span class="src"><code><span class="n">y</span></code></span>
reference.  From this point on, any attempts to use 
<span class="src"><code><span class="n">x</span></code></span>
to manipulate that box will result in a compiler error.
</p>
<p>
We can make a copy of a box using the 
<span class="src"><code><span class="n">clone</span></code></span>
 method which copies over the content of a box and creates a new owned pointer to the copy. So the following code will assign 
<span class="src"><code><span class="n">y</span></code></span>
 to a new owned pointer pointing to a new copy of the value "10". The dereferencing of 
<span class="src"><code><span class="n">x</span></code></span>
 no longer causes a compiler error, as 
<span class="src"><code><span class="n">x</span></code></span>
 still has proper ownership of its box.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">~</span><span class="m">10</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:d}&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</td></tr></table>
</div><p>
But, 
<span class="src"><code><span class="n">x</span></code></span>
and 
<span class="src"><code><span class="n">y</span></code></span>
refer to different boxes now &mdash; a modification of 
<span class="src"><code><span class="o">*</span><span class="n">x</span></code></span>
will not be visible through 
<span class="src"><code><span class="n">y</span></code></span>
.
</p>
<h4 id="Borrowed_References" >Borrowed References</h4>
<p>
All that copying would be expensive, and eliminate the benefits of data
sharing for uses like pass-by-reference and data structures.  Rust's
solution is to provide a way for owners to loan out their objects.  
</p>
<p>
Using the 
<span class="src"><code><span class="o">&amp;</span></code></span>
 operator creates a temporary reference to some memory that has already been allocated. These references are refered to as "borrowed" because they can access the contents of the box during the borrowing period, but do not own the box. This most commonly used to pass in a pointer reference to a method.
</p>
<p>
Because of Rust's emphasis on safety there are many resctriction on what can be done with a reference. Most notably, if a pointer has a borrowed reference in scope (more on scope in the next section), any function which would free the memory or change the type being pointed to would cause a compile-time error. Think of it this way: creating a reference to a box "lends" that box's contents to the reference until the loaned box is "returned".  Thus, a reference owner gives up full control over a loaned box while it is being borrowed.
</p>
<p>
Borrowed references are frequently used as function parameters.  For example,
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">borrow</span><span class="p">(</span><span class="n">r</span> <span class="o">:</span> <span class="o">&amp;</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">r</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
declares the function 
<span class="src"><code><span class="n">borrow</span></code></span>
to take a borrowed pointer to an int.  We can call it by passing in an owned pointer:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">~</span><span class="m">10</span><span class="p">;</span>
    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;borrow(x): {:d}&quot;</span><span class="p">,</span> <span class="n">borrow</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</pre></div>
</td></tr></table>
</div><p>
Borrowed pointers can also be loaned by the borrowee, within the lifetime of the original loan.  We can pass in an owned pointer to borrow2, which borrows that pointer and passes it as a borrowed pointer to borrow:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">borrow2</span><span class="p">(</span><span class="n">r</span> <span class="o">:</span> <span class="o">&amp;</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span> <span class="p">{</span>
   <span class="n">borrow</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h4 id="Pointer_Mutability" >Pointer Mutability</h4>
<p>
As with scalar variables, boxes are immutable by default.  The 
<span class="src"><code><span class="k">mut</span></code></span>
qualifier is used to indicate that a box is mutable.  Mutability applies to the <em>contents</em> of a box, and not the pointer itself.
</p>
<p>
For example,
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">increment</span><span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">r</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
is not permitted:
<pre><code>
borrowed.rs:2:4: 2:6 <span style="color:red;">error:</span> cannot assign to immutable dereference of & pointer
borrowed.rs:2     *r = *r + 1;
                   ^~
</code></pre>
To allow the modification, we need to declare the parameter as a borrowed, mutable reference:
<span class="src"><code><span class="n">r</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">int</span></code></span>
Now, the compiler produces an error for the callsite since the passed object is not mutable:
<pre><code>
borrowed.rs:16:14: 16:15 <span style="color:red;">error:</span> cannot borrow immutable dereference of ~ pointer as mutable
borrowed.rs:16     increment(x);
</code></pre>
</p>
<p>
To change this, we need to add 
<span class="src"><code><span class="k">mut</span></code></span>
to the declaration:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">~</span><span class="m">10</span><span class="p">;</span>
    <span class="n">increment</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</td></tr></table>
</div><p>
The 
<span class="src"><code><span class="k">mut</span></code></span>
here applies to the reference 
<span class="src"><code><span class="n">x</span></code></span>
and is also inherited by the box (so no separate 
<span class="src"><code><span class="k">mut</span></code></span>
annotation is needed for the 
<span class="src"><code><span class="o">~</span></code></span>
.  It allows both the variable 
<span class="src"><code><span class="n">x</span></code></span>
to be reassigned, as well as the contents of the owned box to be modified:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">~</span><span class="m">10</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="o">~</span><span class="m">20</span><span class="p">;</span>
    <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="m">30</span><span class="p">;</span>
</pre></div>
</td></tr></table>
</div><p>
The first assignment statement creates a new box owned by 
<span class="src"><code><span class="n">x</span></code></span>
holding the value
<span class="src"><code><span class="m">20</span></code></span>
. The second assignment statement modifies the value in that box to be
<span class="src"><code><span class="m">30</span></code></span>
.  Without the 
<span class="src"><code><span class="k">mut</span></code></span>
neither assignment would be permitted by the Rust compiler.
</p>
<p>
Borrowed references do not inherit mutability.  For example, this code is invalid:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="k">mut</span> <span class="n">val1</span> <span class="o">=</span> <span class="m">10</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">val2</span> <span class="o">=</span> <span class="m">20</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">borrowed</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">val1</span><span class="p">;</span>
    <span class="n">borrowed</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">val2</span><span class="p">;</span>
    <span class="o">*</span><span class="n">borrowed</span> <span class="o">=</span> <span class="m">11</span><span class="p">;</span>
</pre></div>
</td></tr></table>
</div><p>
<pre><code>
borrowed.rs:23:4: 23:13 <span style="color:red;">error:</span> cannot assign to immutable dereference of & pointer
borrowed.rs:23     *borrowed = 11;
                   <span style="color:red;">^~~~~~~~~</span>
</code></pre>
To allow both modifications, we need:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="k">mut</span> <span class="n">borrowed</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">val1</span><span class="p">;</span>
</pre></div>
</td></tr></table>
</div><p>
 which allows both modifying the referenced box and changing what 
<span class="src"><code><span class="n">borrowed</span></code></span>
 references. 
</p>
<p>
Keep in mind that references are type checked (yet another safety measure of Rust!) so the following code produces an error at compile time due to trying to reassign an int reference to a float reference.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="k">mut</span> <span class="n">val1</span> <span class="o">=</span> <span class="m">10</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">val3</span> <span class="o">=</span> <span class="m">10.0</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">borrowed</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">val1</span><span class="p">;</span>
    <span class="n">borrowed</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">val3</span><span class="p">;</span>
</pre></div>
</td></tr></table>
</div><p>
<pre><code>tut2.rs:4:16: 6:21 <span style="color:red;">error:</span> mismatched types: expected `&&lt;VI0&gt;` but found `&&lt;VF0&gt;` (expected integral variable but found floating-point variable)
tut2.rs:4     borrowed = &val3;
</code></pre>
</p>
<h4 id="Freezing_Objects" >Freezing Objects</h4>
<p>
When an object is loaned through a borrowed reference, the lender loses
the ability to modify that object.  This is especially important for
multi-tasking (which we'll get to soon), but still relevant with a
single thread.
</p>
<p>
For example, the following program produces a compiler error: 
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="m">10</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="m">11</span><span class="p">;</span> <span class="c1">// Error</span>
    <span class="p">}</span>
    <span class="n">x</span> <span class="o">=</span> <span class="m">12</span><span class="p">;</span> <span class="c1">//This is fine</span>
</pre></div>
</td></tr></table>
</div><p>
<pre><code>example.rs:4:9: 4:10 <span style="color:red;">error:</span> cannot assign to `x` because it is borrowed
example.rs:4         x = 11;
</code></pre>
</p>
<p>
When the reference 
<span class="src"><code><span class="n">y</span></code></span>
 borrows the value 
<span class="src"><code><span class="n">x</span></code></span>
refers to, the value of 
<span class="src"><code><span class="n">x</span></code></span>
 is frozen until the reference to it goes out of scope. Thus, the first reassignment here is invalid, but the second (after 
<span class="src"><code><span class="n">y</span></code></span>
is out of scope) is fine.
</p>
<h3 id="Lifetimes" >Lifetimes</h3>
<p>
Memory allocated in Rust is automatically freed when its owner either goes out of scope or is reassigned. This eliminates the need to explicitly free storage (as in C or C++), but guarantees safety without giving up control to a garbage collector.  
</p>
<p>
Owned pointers follow similar rules of deallocation, so borrowing a reference to some box and trying to access it once it has gone out of scope throws a compiler error.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="k">mut</span> <span class="n">reference</span><span class="o">:</span> <span class="o">&amp;~</span><span class="k">int</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">val</span><span class="o">:</span> <span class="o">~</span><span class="k">int</span> <span class="o">=</span> <span class="o">~</span><span class="m">10</span><span class="p">;</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">//val deallocated here</span>
    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:d}&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">reference</span><span class="p">);</span> <span class="c1">//Referencing something that&#39;s gone!</span>
</pre></div>
</td></tr></table>
</div><p>
<pre><code>example.rs:4:21: 4:25 <span style="color:red;">error:</span> borrowed value does not live long enough
example.rs:4         reference = &val;
</code></pre>
</p>
<h2 id="Vectors_and_Strings" >Vectors and Strings</h2>
<p>
Rust provides built-in vector and string types, consistent with Rust's focus on safety.
</p>
<h4 id="Vectors" >Vectors</h4>
<p>
<a name="vectors"></a>
A vector is defined by using comma seperated values within brackets. 
</p>
<p>
A specific element can be accessed via 
<span class="src"><code><span class="n">foo</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></code></span>
. Any vector definition where the elements may change after the initial definition should be an owned box, so the methods of
<a href="http://static.rust-lang.org/doc/0.9/std/vec/trait.OwnedVector.html">std::vec::OwnedVector</a>
 may be used to mutate the vector. 
</p>
<p>
These examples show simple vector functions:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="k">mut</span> <span class="n">vec</span> <span class="o">=</span> <span class="o">~</span><span class="p">[</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">];</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="m">3</span><span class="p">);</span> <span class="c1">// Appends to end: [0, 1, 2, 3]</span>

    <span class="n">vec</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">10</span><span class="p">);</span> 
    <span class="c1">// Inserts 10 at position 2: [0, 1, 10, 2, 3]</span>

    <span class="k">let</span> <span class="n">last</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> 
    <span class="c1">// Returns last element, removing it from the vector: [0, 1, 10, 2]</span>

    <span class="k">let</span> <span class="n">element1</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="m">1</span><span class="p">);</span> 
    <span class="c1">// Returns and removes element at specified index: [0, 10, 2]</span>

    <span class="c1">// An iterator for going through all elements in order: </span>
    <span class="k">for</span> <span class="o">&amp;</span><span class="n">x</span> <span class="n">in</span> <span class="n">vec</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// note the use of &amp; for borrowing</span>
        <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// len() returns the number of elements in the vector</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">len</span><span class="p">())</span> <span class="p">{</span> 
        <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h4 id="Strings" >Strings</h4>
<p>
Rust supposrts a 
scdoe
string
edoc
type which is a vector of characters.  Each character is a UTF-8 sequence, represented by the
<span class="src"><code><span class="k">u8</span></code></span>
type in Rust.
</p>
<p>
A notable construct that is very important for strings is the 
<span class="src"><code><span class="n">slice</span></code></span>
. This represents a view into a string, but not a string itself. Its type is
<span class="src"><code><span class="o">&amp;</span><span class="n">string</span></code></span>
.  
 
Methods that produce a slice include 
<span class="src"><code><span class="n">slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">,</span> <span class="n">begin</span><span class="o">:</span> <span class="k">int</span><span class="p">,</span> <span class="n">end</span><span class="o">:</span> <span class="k">int</span><span class="p">)</span></code></span>
, which returns a slice of characters between begin and end - 1, 
<span class="src"><code><span class="n">slice_from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">,</span> <span class="n">begin</span><span class="o">:</span> <span class="k">int</span><span class="p">)</span></code></span>
, which returns a slice with first element from the index provided that continues to the end, and 
<span class="src"><code><span class="n">slice_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">,</span> <span class="n">end</span><span class="o">:</span> <span class="k">int</span><span class="p">)</span></code></span>
, which returns a slice starting at the beginning with final element from index end - 1. 
</p>
<p>
These slice methods produce an immutable values, so they cannot be modified. 
</p>
<p>
To do something such as taking a substring, a slice may be converted to an owned string via the
<span class="src"><code><span class="n">to_owned</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">)</span></code></span>
 method.  These slice methods work on any vector, but string manipulation is the most common use of slices.
</p>
<p>
Other notable string methods include 
<span class="src"><code><span class="k">str</span><span class="o">::</span><span class="n">eq</span><span class="p">(</span><span class="o">&amp;~</span><span class="k">str</span><span class="p">,</span> <span class="o">&amp;~</span><span class="k">str</span><span class="p">)</span></code></span>
which checks two strings for bytewise equality, and 
<span class="src"><code><span class="n">split</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">,</span> <span class="n">char</span><span class="p">)</span></code></span>
 which returns an iterator that splits the string the method is called on into slices delimited by the parameter character. 
</p>
<p>
For string concatenation, the 
<span class="src"><code><span class="o">+</span></code></span>
 operator is used. 
</p>
<p>
These methods are used in the example below:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="src"><pre>    <span class="k">let</span> <span class="n">string</span> <span class="o">=</span> <span class="o">~</span><span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">subst1</span> <span class="o">=</span> <span class="n">string</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">16</span><span class="p">).</span><span class="n">to_owned</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">subst2</span> <span class="o">=</span> <span class="n">string</span><span class="p">.</span><span class="n">slice_from</span><span class="p">(</span><span class="m">10</span><span class="p">).</span><span class="n">to_owned</span><span class="p">();</span>
    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="k">str</span><span class="o">::</span><span class="n">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subst1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subst2</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">doublesub</span> <span class="o">=</span> <span class="n">subst1</span> <span class="o">+</span> <span class="n">subst2</span><span class="p">;</span>
    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">doublesub</span><span class="p">);</span>
    <span class="c1">// Using split iterator to print word by word</span>
    <span class="k">for</span> <span class="n">tempstr</span> <span class="n">in</span> <span class="n">string</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">tempstr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Another useful function of the split iterator</span>
    <span class="c1">// collect() Creates a vector ~[&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;string&quot;]</span>
    <span class="k">let</span> <span class="n">wordvec</span><span class="o">:</span> <span class="o">~</span><span class="p">[</span><span class="o">&amp;</span><span class="k">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">string</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span> 
    <span class="k">for</span> <span class="o">&amp;</span><span class="n">s</span> <span class="n">in</span> <span class="n">wordvec</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h4 id="Exercises" >Exercises</h4>
<p>
<div class="exercise">
<b>Exercise 2.1.</b>  Implement a function, 
<span class="src"><code><span class="n">increment</span></code></span>
that takes as input a vector of integers and returns a new vector of integers that has the values of the original list each incremented by one.  For example:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">~</span><span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">];</span>
   <span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="n">increment</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
   <span class="k">for</span> <span class="o">&amp;</span><span class="n">x</span> <span class="n">in</span> <span class="n">q</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">print</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:d} &quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
should print out 2 3 4.
</div>
</p>
<p>
<div class="exercise">
<b>Exercise 2.2.</b>  Implement a function, 
<span class="src"><code><span class="n">incrementMut</span></code></span>
that takes as input a vector of integers and modifies the values of the original list by incrementing each value by one.  For example:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="src"><pre><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="o">~</span><span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">];</span>
   <span class="n">incrementMut</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
   <span class="k">for</span> <span class="o">&amp;</span><span class="n">x</span> <span class="n">in</span> <span class="n">p</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">print</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:d} &quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
should print out 2 3 4.  
</div>
</p>
<h2 id="Basic_I/O" >Basic I/O</h2>
<p>
Rust handles file and user input/output using the 
<a href="http://static.rust-lang.org/doc/0.9/std/io/index.html">std::io</a>
 module. 
</p>
<p>
The most intuitive way to work with these is through the use of a 
<a href="http://static.rust-lang.org/doc/0.9/std/io/buffered/struct.BufferedReader.html">BufferedReader, </a>
which will be explained more in depth in the following sections. Take note that many methods in 
<span class="src"><code><span class="n">BufferedReader</span></code></span>
return vectors of bytes, not strings, so appropriate conversions may be necessary.
</p>
<h3 id="Working_with_Standard_Input_(stdin)" >Working with Standard Input (stdin)</h3>
<p>
Standard input is provided through 
<span class="src"><code><span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">stdin</span></code></span>
, and implemented by creating a buffered reader.  The following example (taken from the Rust documentation) prints out a series of lines from standard input, automatically stopping at the end of input. The 
<span class="src"><code><span class="n">lines</span></code></span>
 method returns an iterator that goes through each line until the end of imput.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="src"><pre><span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">buffered</span><span class="o">::</span><span class="n">BufferedReader</span><span class="p">;</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">stdin</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">main</span><span class="p">(){</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stdin</span> <span class="o">=</span> <span class="n">BufferedReader</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">stdin</span><span class="p">());</span>
    <span class="k">for</span> <span class="n">line</span> <span class="n">in</span> <span class="n">stdin</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">print</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
Reading line by line is a bit more difficult, as the 
<span class="src"><code><span class="n">read_line</span></code></span>
 method is of an 
<span class="src"><code><span class="n">Option</span><span class="o">&lt;~</span><span class="k">str</span><span class="o">&gt;</span></code></span>
 type. These option types are explained more in depth in the "Error Handling" section later on this page of the tutorial. The gist of it is the following though: a call to 
<span class="src"><code><span class="n">read_line</span></code></span>
 can either succeed or fail. Thus, when it is called, we need a match statement to determine if it succeeded (where it will return 
<span class="src"><code><span class="n">line</span></code></span>
 in the following example) or fail (which returns
<span class="src"><code><span class="n">None</span></code></span>
). The example code below reads in the next 5 lines from stdin, and prints them. If there are less than 5 lines, the loop ends without crashing the program.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="src"><pre><span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">buffered</span><span class="o">::</span><span class="n">BufferedReader</span><span class="p">;</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">stdin</span><span class="p">;</span>
<span class="k">fn</span> <span class="n">main</span><span class="p">(){</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stdin</span> <span class="o">=</span> <span class="n">BufferedReader</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">stdin</span><span class="p">());</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">stdin</span><span class="p">.</span><span class="n">read_line</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">Some</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="n">print</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">None</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="n">println</span><span class="p">(</span><span class="s">&quot;End of input!&quot;</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h3 id="Files" >Files</h3>
<p>
The standard library functions for working with files in Rust are handled via the 
<a href="http://static.rust-lang.org/doc/0.9/std/io/fs/struct.File.html">std::io::File</a>
 module. This module contains methods for opening and writing to a file. 
</p>
<p>
A file is opened using
<span class="src"><code><span class="n">Path</span></code></span>
 objects, which are included in any Rust program by default. Creating a 
<span class="src"><code><span class="n">Path</span></code></span>
 object is done through 
<span class="src"><code><span class="n">Path</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;path/to/file.foo&quot;</span><span class="p">)</span></code></span>
. 
</p>
<p>
To simply open a new file for writing,
<span class="src"><code><span class="n">File</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Path</span><span class="p">)</span></code></span>
 is the simplest call. This returns an 
edoc
Option<File>
<span class="src"><code> <span class="k">type</span></code></span>
, so it must be matched to ensure that a file was successfully opened. 
</p>
<p>
The two most common ways to write to the file once opened are: <br>
<span class="src"><code>   <span class="n">File</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="k">u8</span><span class="p">])</span></code></span>
which writes a buffer of bytes to a file, and: <br>
<span class="src"><code>   <span class="n">File</span><span class="o">::</span><span class="n">write_str</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">str</span><span class="p">)</span></code></span>
which writes a string to the file.
</p>
<p>
This example demonstrated opening a file for writing using both of these methods:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="src"><pre><span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">match</span> <span class="n">File</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Path</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;message.txt&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">file</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">file</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">bytes</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;line one</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
            <span class="n">file</span><span class="p">.</span><span class="n">write_str</span><span class="p">(</span><span class="s">&quot;line two</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">None</span> <span class="o">=&gt;</span><span class="p">{</span>
            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Opening message.txt failed!&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
Reading a file can be accomplished easily through using the 
<a href="http://static.rust-lang.org/doc/0.9/std/io/buffered/struct.BufferedReader.html">BufferedReader</a>
 module, much like reading from standard in. 
</p>
<p>
Opening a file to a 
<span class="src"><code><span class="n">BufferedReader</span></code></span>
 is done using the 
<span class="src"><code><span class="n">File</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Path</span><span class="p">)</span></code></span>
 function, which opens the file at a given path in read-only mode, followed by 
<span class="src"><code><span class="n">BufferedReader</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">File</span><span class="p">)</span></code></span>
. 
</p>
<p>
Note that the file needs to be matched before converting to a 
<span class="src"><code><span class="n">BufferedReader</span></code></span>
, as 
<span class="src"><code><span class="n">File</span><span class="o">::</span><span class="n">open</span></code></span>
returns an 
<span class="src"><code><span class="n">Option</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span></code></span>
 type. Once converted to a 
<span class="src"><code><span class="n">BufferedReader</span></code></span>
, a file is read in an identical manner to reading from stdin in the previous example, and all relevant methods are outlined on the
<a href="http://static.rust-lang.org/doc/0.9/std/io/buffered/struct.BufferedReader.html">BufferedReader</a>
 documentation.
</p>
<p>
Here's a simple example of reading a file:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="src"><pre><span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">buffered</span><span class="o">::</span><span class="n">BufferedReader</span><span class="p">;</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">match</span> <span class="n">File</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Path</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;message.txt&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">Some</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">BufferedReader</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
            <span class="c1">//reading from file</span>
        <span class="p">}</span>
        <span class="n">None</span> <span class="o">=&gt;</span><span class="p">{</span>
            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Opening message.txt failed!&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><p>
The 
<span class="src"><code><span class="n">File</span><span class="o">::</span><span class="n">open_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Path</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">,</span> <span class="n">FileAccess</span><span class="p">)</span></code></span>
 method allows specifying the mode in which a file is accessed. 
<span class="src"><code><span class="n">FileMode</span></code></span>
 and 
<span class="src"><code><span class="n">FileAccess</span></code></span>
 are enumerable types imported from 
<a href="http://static.rust-lang.org/doc/0.9/std/io/enum.FileMode.html">std::io::FileMode</a>
 and 
<a href="http://static.rust-lang.org/doc/0.9/std/io/enum.FileAccess.html">std::io::FileAccess</a>
 respectively. For example, to open a file with read and write access, positioned to append to the end of the file, the following must be included, and then called as so.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="src"><pre><span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="p">{</span><span class="n">File</span><span class="p">,</span> <span class="n">Append</span><span class="p">,</span> <span class="n">ReadWrite</span><span class="p">};</span>
<span class="cm">/*</span>
<span class="cm">...</span>
<span class="cm">*/</span>
<span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="n">File</span><span class="o">::</span><span class="n">open_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Path</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;message.txt&quot;</span><span class="p">),</span> <span class="n">Append</span><span class="p">,</span> <span class="n">ReadWrite</span><span class="p">);</span>
</pre></div>
</td></tr></table>
</div><p>
Like the other file methods, this returns an
<span class="src"><code><span class="n">Option</span></code></span>
objects that must be matched to check for opening failures.
</p>
<h2 id="Error_Handling" >Error Handling</h2>
<p>
Error handling in Rust is done with the intention of catching what can be caught at compile-time, and reducing runtime errors. We've seen the 
<span class="src"><code><span class="n">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></span>
 type used for functions which either create an object or fail (represented by 
<span class="src"><code><span class="n">None</span><span class="p">()</span></code></span>
). There is another, similar construct to this called a 
<span class="src"><code><span class="n">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">E</span><span class="o">&gt;</span></code></span>
 which is like a 
<span class="src"><code><span class="n">Option</span></code></span>
, but determined on whether a function succeds as intended on a pre-existing object (as opposed to the creation of a new object with 
<span class="src"><code><span class="n">Option</span></code></span>
). 
</p>
<p>
A 
<span class="src"><code><span class="n">Result</span></code></span>
 requires a match statement to use the values obtained. The 
<span class="src"><code><span class="n">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></code></span>
 branch represents a successful call, whereas 
<span class="src"><code><span class="n">Err</span><span class="p">(</span><span class="n">E</span><span class="p">)</span></code></span>
 is a failed called. The error result may provide specific information about the failure, depending on the function.
</p>
<p>
If a 
<span class="src"><code><span class="n">None</span><span class="p">()</span></code></span>
 or 
<span class="src"><code><span class="n">Err</span><span class="p">(</span><span class="n">E</span><span class="p">)</span></code></span>
 branch is reached and the program can no longer continue, a 
<span class="src"><code><span class="k">fail</span><span class="o">!</span><span class="p">()</span></code></span>
 macro can be used to terminate a program with an optional message. 
</p>
<p>
The following code terminates with a message if "foo.txt" is failed to open:
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="src"><pre><span class="k">match</span> <span class="n">File</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Path</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;foo.txt&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">file</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="n">None</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">fail</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Creating foo.txt failed!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h2 id="Example:_Secret_Sharing" >Example: Secret Sharing</h2>
<p>
The XOR operation is a simple, but effective method for hiding meaning.
It's derived from the identity <code>A = (A ^ B) ^ B</code>.  XOR-ing a
message with a random key provides <em>perfect</em> encryption, known as
a <em>one-time pad</em>. It is essentially the only form of encryption
that is information-theoretically secure, but is impractical for most
purposes since it requires a perfectly-random key as long as the
message and that key can never be reused.
</p>
<p>
It works by taking in a message and a random bit sequence (key) of equal
length. Each bit in the message is XORed with the corresponding bit in
the key to produce the encrypted message. The original message can then
be recovered by applying the XOR process to the key and the encrypted
message.
</p>
<p>
For this exercise, we will use this strategy to convert a plaintext file
into two secret shares, each of which discloses no information about the
original file (other than its length), but if someone has both shares
they can put them together to produce the original file.  A paranoid
individual might use such an approach to store a file in the cloud by
storing one share using Dropbox and the other share using Google Docs.
The user could acquire both shares to obtain the file, and if the NSA
can hypothetically (of course) obtain all of the data from one of the
services but not both of them, it would not be enough to learn the
contents of the file.
</p>
<p>
Note that our implementation uses 
<span class="src"><code><span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="o">::</span><span class="n">random</span></code></span>
to generate the random key.  This is not cryptographically strong randomness, so should be used for entertainment purposes only!  (If you are interested in better random numbers, see <a href="https://github.com/wbkostan/cs4414-ps4">tRustees: True Random Number Generation</a>.)
</p>
<p>
We'll provide the code to do the splitting, and leave it as
an exercise for you to write the joining code.
</p>
<h3 id="Splitter" >Splitter</h3>
<p>
The following Rust code implements the splitter.  It takes as input the
name of a file, and writes out two share files.
</p>
<div class="notab"><table class="srctable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></div></td><td class="code"><div class="src"><pre><span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="o">::</span><span class="n">random</span><span class="p">;</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">os</span><span class="p">;</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">args</span><span class="o">:</span> <span class="o">~</span><span class="p">[</span><span class="o">~</span><span class="k">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">::</span><span class="n">args</span><span class="p">();</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="o">!=</span> <span class="m">2</span> <span class="p">{</span>
        <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Usage: {:s} &lt;inputfile&gt;&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span> 
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">fname</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span>
        <span class="k">let</span> <span class="n">msg_file</span> <span class="o">=</span> <span class="n">File</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>

        <span class="k">match</span> <span class="p">(</span><span class="n">msg_file</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">msg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">msg_bytes</span><span class="o">:</span> <span class="o">~</span><span class="p">[</span><span class="k">u8</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">read_to_end</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">share1_file</span> 
                       <span class="o">=</span> <span class="n">File</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Path</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">fname</span> <span class="o">+</span> <span class="s">&quot;.share1&quot;</span><span class="p">));</span>
                <span class="k">let</span> <span class="n">share2_file</span> 
                       <span class="o">=</span> <span class="n">File</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Path</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">fname</span> <span class="o">+</span> <span class="s">&quot;.share2&quot;</span><span class="p">));</span>
                
                <span class="k">match</span> <span class="p">(</span><span class="n">share1_file</span><span class="p">,</span> <span class="n">share2_file</span><span class="p">)</span> <span class="p">{</span>
                    <span class="p">(</span><span class="n">Some</span><span class="p">(</span><span class="n">share1</span><span class="p">),</span> <span class="n">Some</span><span class="p">(</span><span class="n">share2</span><span class="p">))</span> <span class="o">=&gt;</span> <span class="p">{</span> 
                        <span class="n">split</span><span class="p">(</span><span class="n">msg_bytes</span><span class="p">,</span> <span class="n">share1</span><span class="p">,</span> <span class="n">share2</span><span class="p">);</span> 
                        <span class="p">}</span> <span class="p">,</span>
                    <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">fail</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Error opening output files!&quot;</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="p">,</span>
            <span class="n">None</span> <span class="o">=&gt;</span> <span class="k">fail</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Error opening message file: {:s}&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">xor</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="k">u8</span><span class="p">],</span> <span class="n">b</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="k">u8</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="p">[</span><span class="k">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">~</span><span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">())</span> <span class="p">{</span>
	<span class="n">ret</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">ret</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">split</span><span class="p">(</span><span class="n">msg_bytes</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="k">u8</span><span class="p">],</span> <span class="k">mut</span> <span class="n">share1</span><span class="o">:</span> <span class="n">File</span><span class="p">,</span> <span class="k">mut</span> <span class="n">share2</span><span class="o">:</span> <span class="n">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">random_bytes</span><span class="o">:</span> <span class="o">~</span><span class="p">[</span><span class="k">u8</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="p">[];</span>
    <span class="c1">// This is not cryptographically strong randomness! </span>
    <span class="c1">// (For entertainment purposes only.)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">msg_bytes</span><span class="p">.</span><span class="n">len</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">random_byte</span> <span class="o">=</span> <span class="n">random</span><span class="p">();</span>
	<span class="n">random_bytes</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">random_byte</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">let</span> <span class="n">encrypted_bytes</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">msg_bytes</span><span class="p">,</span> <span class="n">random_bytes</span><span class="p">);</span>
    <span class="n">share1</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">random_bytes</span><span class="p">);</span>
    <span class="n">share2</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">encrypted_bytes</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div><h4 id="Joiner" >Joiner</h4>
<p>
<div class="exercise"> 
</p>
<p>
<b>Exercise 2.3.</b> Implement the joiner.  It
should take two file names as its inputs, and output to standard output
the result of XOR-ing the bytes in those files.  The inputs files must be the same length.
</p>
<p>
</div>
</p>
<p>
Your joiner should be able to produce the plaintext from the example
files: <a href="http://aml3.github.io/RustTutorial/code/msg.share1">msg.share1</a> and <a href="http://aml3.github.io/RustTutorial/code/msg.share1">msg.share2</a>.  You should download these files (look
at them to confirm they appear to be random bytes).  
</p>
<p>
Then, try executing:
<pre><code>
joiner msg.share1 msg.share2
</code>
</pre>
</p>
<p>
If you implemented the joiner correctly, you should see a (somewhat)
<a href="http://www.gutenberg.org/cache/epub/1518/pg1518.html">meaningful message</a>.
</p>
<p>
<div class="credits">
This tutorial was created by Alex&nbsp;Lamana, Rob&nbsp;Michaels, Wil&nbsp;Thomason, and David&nbsp;Evans for <a href="http://rust-class.org">University of Virginia cs4414 Spring 2014</a>.
</div>
    </body>
                </html>