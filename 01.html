<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="style.css" rel="stylesheet" type="text/css">
<title>01</title>
</head>

<body>
<h1 id="syntax-variables-and-functions">Syntax - Variables and Functions</h1>
<p>Rust's syntax is heavily influenced by C/C++. For example, the scope of blocks
is determined by braces (<code>{</code> and <code>}</code>), and statements end with a <code>;</code>. Like other
C-family languages, whitespace (e.g. tabs and spaces) is ignored by the compiler. </p>
<p>Unlike C/C++, we create a function using the <code>fn</code> keyword.</p>
<table>
	<tr>
		<td>
		<pre><code class="rust">
fn main() {
	println("Hello World");
}
		</code></pre>
		</td>
		<td>
		<pre><code class="java">
public static void main(String[] args) {
	System.out.println("Hello World");
}
		</code></pre>
		</td>
	</tr>
</table>

<p>A better example would be something like the following.</p>
<table>
	<tr>
		<td>
			<pre><code class="rust">
fn main() {
	let x = get_hello();
	println(x); // prints `Hello World!`

	// variables can be redeclared with the same name
	let x = get_hello2();
	println(x); // prints `Hello World, again!`
}

fn get_hello() -> ~str {
	return "Hello World!";
}

// lines without a `;` are the same as using a return statement
fn get_hello2() -> ~str {
	"Hello World, again!"
}
			</code></pre>
		</td>
		<td>
			<pre><code class="java">
public static void main(String[] args) {
	String x = get_hello();
	System.out.println(x); // prints `Hello World!`
}

public String get_hello() {
	return "Hello World!";
}
			</code></pre>
		</td>
	</tr>
</table>

<p>Several things are going on in this code. First, variables are declared using 
the <code>let</code> keyword. Notice that we didn't have to specify a type, such as <code>str</code>.
The Rust compiler can infer types, as long as there isn't any ambiguity. If 
something is ambiguous, a type can be specificied using <code>variable-name :type</code>.</p>
<pre><code class="rust">let x = 4; // uses the compiler default
let y: uint = 4; // forces y to be an unsigned integer
let z: i32 = 4; // forces z to be a 32-bit integer
</code></pre>

<p>Second, we specified a return type using <code>-&gt;</code>. This is fairly straightforward. 
Any valid type can be returned by a function.</p>
<p>Third, there's a <code>&amp;</code> in the return type. This is will discussed in the <a href="file:///home/wil/RustTutorial/markdown/03.md">third 
section</a>. The next section deals with the basics of Rust variables and 
syntax.</p>
<hr />
<p><a href="http://aml3.github.io/RustTutorial/html/02.md">Next</a></p></body></html>
